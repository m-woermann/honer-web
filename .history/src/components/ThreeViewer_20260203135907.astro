---
// ThreeViewer.astro - A Three.js viewer component for Astro
import positioningData from '../config/positioning.json';
// Dynamically import all speaker JSON files from config/speakers directories
const speakerFiles = await Astro.glob('../config/speakers/*.json');

// Create speaker config map from dynamically imported configs
const speakerConfigs: Record<string, any> = {};
speakerFiles.forEach(speakerFile => {
    const config = speakerFile.default;
    speakerConfigs[config.id] = config;
    console.log('Loaded speaker config:', config.id, config.name);
});

console.log('Total speaker configs loaded:', Object.keys(speakerConfigs).length);
console.log('Available speaker IDs:', Object.keys(speakerConfigs));
console.log('Positioning stacks loaded:', positioningData.stacks.length);
---
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Michroma&family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

<div class="viewer-container">
  <canvas class="webgl"></canvas>
  <div class="crosshair-cursor" id="crosshair"></div>
  <div class="speaker-selector-hint" id="speakerSelectorHint">SPEAKER SELECTOR</div>
  
  <!-- Loading screen -->
  <div class="loading-screen" id="loadingScreen">
    <div class="loading-content">
      <h2>STACKING BOXES ...</h2>
      <div class="loading-bar">
        <div class="loading-progress" id="loadingProgress"></div>
      </div>
      <p id="loadingText">Initializing...</p>
    </div>
  </div>
  
  <!-- Main heading -->
  <div class="main-heading">
    <h1>HORNER AUDIO</h1>
  </div>
  
  <div class="overlay" id="speakerOverlay">
    <div class="overlay-content">
      <h2>Loading...</h2>
      <div class="specs">
        <!-- Dynamic content will be populated here -->
      </div>
      <button class="detail-button" id="detailButton">View Details</button>
    </div>
  </div>

  <!-- Bottom static banner -->
  <div class="bottom-banner">
    <div class="banner-content">
      <!-- Mobile-only navigation buttons (will be moved to top in mobile grid) -->
      <button class="banner-link mobile-nav-btn nav-left-mobile" id="navLeftMobile" aria-label="Previous stack">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M15 18l-6-6 6-6"/>
        </svg>
      </button>
      <button class="banner-link mobile-nav-btn nav-right-mobile" id="navRightMobile" aria-label="Next stack">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M9 18l6-6-6-6"/>
        </svg>
      </button>
      
      <span class="banner-link products-link">PRODUCTS</span>
      <span class="banner-separator">•</span>
      <span class="banner-link projects-link">PROJECTS</span>
      <span class="banner-separator">•</span>
      <span class="banner-link contact-link">CONTACT</span>
      <span class="banner-separator">•</span>
      <span class="banner-link about-link">ABOUT</span>
      <span class="banner-separator">•</span>
      <span class="banner-link impressum-link">IMPRESSUM</span>
    </div>
  </div>

  <!-- Stack navigation arrows -->
  <div class="stack-navigation">
    <button class="nav-arrow nav-left" id="navLeft" aria-label="Previous stack">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M15 18l-6-6 6-6"/>
      </svg>
    </button>
    <button class="nav-arrow nav-right" id="navRight" aria-label="Next stack">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M9 18l6-6-6-6"/>
      </svg>
    </button>
  </div>
</div>

<!-- Pass data from frontmatter to client script -->
<script is:inline define:vars={{positioningData, speakerConfigs}}>
  window.speakerData = {positioningData, speakerConfigs};
  console.log('Client-side data loaded:');
  console.log('- Positioning stacks:', positioningData.stacks.length);
  console.log('- Speaker configs:', Object.keys(speakerConfigs).length);
  console.log('- Available speakers:', Object.keys(speakerConfigs));
</script>

<style>
  /* Minimum sizing constraints to prevent scaling problems */
  * {
    min-width: 0;
    min-height: 0;
  }
  
  html {
    min-width: 320px; /* Minimum viewport width */
    font-size: clamp(14px, 2.5vw, 16px); /* Responsive base font size with limits */
  }
  
  body {
    min-width: 320px;
    min-height: 100vh;
  }

  :root {
    --color-anthracite: #383e42;  /* RAL 7016 Anthracite Grey */
    --color-green: #42cc5d;       /* Horner Audio Green */
    --color-dark-bg: #1a1a1a;     /* Dark background */
    --color-light-grey: #A8BAC6;  /* Light grey for ground */
  }

  .viewer-container {
    width: 100%;
    height: 100vh;
    margin: 0;
    padding: 0;
    position: relative;
  }
  .webgl {
    width: 100%;
    height: 100%;
    cursor: none; /* Hide default cursor */
  }

  /* Speaker selector hint */
  .speaker-selector-hint {
    position: fixed;
    font-family: 'Michroma', sans-serif;
    font-size: 0.9rem;
    color: #42cc5d;
    letter-spacing: 1px;
    pointer-events: none;
    z-index: 9998;
    transform: translate(5px, -25px);
    opacity: 1;
    transition: opacity 1s ease-out;
    white-space: nowrap;
  }

  .speaker-selector-hint.fade-out {
    opacity: 0;
  }

  /* Custom crosshair cursor for 3D viewer */
  .crosshair-cursor {
    position: fixed;
    width: 21px;
    height: 21px;
    pointer-events: none;
    z-index: 9999;
    transform: translate(-50%, -50%);
    opacity: 0;
    transition: opacity 0.1s;
  }

  .crosshair-cursor::before,
  .crosshair-cursor::after {
    content: '';
    position: absolute;
    background: #000;
  }

  .crosshair-cursor::before {
    /* Horizontal line */
    width: 42px;
    height: 1px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }

  .crosshair-cursor::after {
    /* Vertical line */
    width: 1px;
    height: 42px;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }

  .viewer-container:hover .crosshair-cursor {
    opacity: 1;
  }

  /* Loading screen */
  .loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    background: var(--color-dark-bg);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    transition: opacity 0.5s ease;
  }

  .loading-screen.hidden {
    opacity: 0;
    pointer-events: none;
  }

  .loading-content {
    text-align: center;
    color: white;
  }

  .loading-content h2 {
    font-family: 'Michroma', sans-serif;
    color: var(--color-green);
    margin-bottom: 2rem;
    font-size: 1.5rem;
  }

  .loading-bar {
    width: 300px;
    height: 4px;
    background: color-mix(in srgb, var(--color-green) 20%, transparent);
    border-radius: 0;
    overflow: hidden;
    margin: 0 auto 1rem;
  }

  .loading-progress {
    height: 100%;
    background: var(--color-green);
    width: 0%;
    transition: width 0.3s ease;
    box-shadow: 0 0 10px color-mix(in srgb, var(--color-green) 50%, transparent);
  }

  .loading-content p {
    font-family: 'Roboto', sans-serif;
    color: #999;
    font-size: 0.9rem;
  }

  /* Main heading */
  .main-heading {
    position: fixed;
    top: 40px;
    left: 40px;
    z-index: 1000;
    pointer-events: none;
    min-width: 200px; /* Minimum width to prevent collapse */
  }

  .main-heading h1 {
    font-family: 'Michroma', sans-serif;
    font-size: clamp(2rem, 5vw, 3rem); /* Responsive with min/max limits */
    min-font-size: 2rem; /* Fallback minimum */
    font-weight: 400;
    color: var(--color-green);
    margin: 0;
    text-shadow: 0 0 20px color-mix(in srgb, var(--color-green) 30%, transparent);
    letter-spacing: clamp(1px, 0.5vw, 3px); /* Responsive letter spacing */
    min-width: max-content; /* Prevent text wrapping */
    white-space: nowrap;
  }

  .overlay {
    position: fixed;
    top: 20px;
    right: 20px;
    width: 420px;
    min-width: 375px; /* Minimum overlay width */
    max-width: 90vw; /* Maximum width on small screens */
    background: transparent;
    border-radius: 10px;
    display: none;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.3s ease, transform 0.3s ease;
    transform: translateX(20px);
  }
  .overlay.visible {
    display: block;
    opacity: 1;
    transform: translateX(0);
  }
  .overlay-content {
    padding: 1.5rem;
    color: white;
    position: relative;
    font-family: 'Roboto', sans-serif;
    text-align: right;
  }
  .overlay-content p {
    font-family: 'Roboto', sans-serif;
    margin: 0.5rem 0;
  }
  .specs {
    margin-top: 1rem;
  }
  .specs strong,
  .specs p strong,
  .overlay .specs strong,
  .overlay-content .specs strong,
  .overlay-content .specs p strong {
    font-family: 'Michroma', sans-serif !important;
    letter-spacing: 1px !important;
    font-size: 0.85rem !important;
    color: #42cc5d !important;
    font-weight: 400 !important;
  }
  .spec-item {
    margin: 0.5rem 0;
    padding: 0.4rem 0.8rem;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 0;
    font-size: 0.9rem;
    font-family: 'Roboto', sans-serif !important;
  }
  .spec-item .spec-label,
  .spec-item .spec-value {
    font-family: 'Roboto', sans-serif;
  }
  h3 {
    color: white;
    margin: 0 0 1rem 0;
    font-size: 1.3rem;
    font-weight: 600;
    font-family: 'Michroma', sans-serif;
  }
  h2 {
    color: white;
    margin: 0 0 1rem 0;
    font-size: 1.3rem;
    font-weight: 600;
    font-family: 'Michroma', sans-serif;
  }
  .detail-button {
    background: #383e42;
    color: #42cc5d;
    border: 1px solid #42cc5d;
    padding: 0.5rem 1rem;
    border-radius: 0;
    font-family: 'Michroma', sans-serif;
    font-size: 0.9rem;
    font-weight: 400;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 2px;
    cursor: pointer;
    margin-top: 1rem;
    width: 100%;
    transition: all 0.3s ease;
    text-shadow: none;
  }
  .detail-button:hover {
    color: #42cc5d;
    text-shadow: 0 0 8px rgba(66, 204, 93, 0.5);
    border-color: #42cc5d;
  }

  /* Bottom static banner */
  .bottom-banner {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 60px;
    background: transparent;
    z-index: 999;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .banner-content {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 1rem;
    flex-wrap: wrap;
    padding: 0 2rem;
    min-height: 40px; /* Minimum banner content height */
  }

  .banner-link {
    font-family: 'Michroma', sans-serif;
    font-size: clamp(12px, 2.5vw, 14px); /* Responsive font size with limits */
    min-font-size: 12px; /* Fallback minimum */
    font-weight: 400;
    color: var(--color-green);
    letter-spacing: clamp(1px, 0.3vw, 2px); /* Responsive letter spacing */
    cursor: pointer;
    transition: all 0.3s ease;
    text-decoration: none;
    white-space: nowrap; /* Prevent text wrapping */
    min-width: max-content;
  }

  .banner-link:hover {
    color: var(--color-green);
    text-shadow: 0 0 8px color-mix(in srgb, var(--color-green) 50%, transparent);
  }

  .banner-separator {
    font-family: 'Michroma', sans-serif;
    font-size: 14px;
    color: var(--color-green);
    letter-spacing: 2px;
  }

  /* Hide mobile navigation buttons on desktop */
  .mobile-nav-btn {
    display: none;
  }

  .mobile-nav-btn svg {
    display: inline-block;
    vertical-align: middle;
  }

  /* Responsive design for mobile/narrow screens */
  @media (max-width: 768px) {
    .overlay {
      top: 120px; /* Move below the heading */
      left: 20px;
      right: 20px;
      width: auto; /* Use full width minus margins */
      min-width: 280px; /* Ensure minimum overlay width */
      max-width: calc(100vw - 40px); /* Prevent overflow */
      transform: translateY(-20px); /* Change to vertical slide */
    }
    
    .overlay.visible {
      transform: translateY(0);
    }
    
    .main-heading h1 {
      font-size: clamp(2rem, 6vw, 2.5rem); /* Responsive heading for mobile */
      min-font-size: 2rem; /* Minimum mobile heading size */
      letter-spacing: clamp(1px, 0.2vw, 1px);
    }
    
    .main-heading {
      top: 20px; /* Reduce top margin */
      left: 50%; /* Center horizontally */
      transform: translateX(-50%); /* Perfect centering */
      text-align: center;
      min-width: 200px; /* Ensure minimum width */
    }

    .bottom-banner {
      height: auto;
      padding: 1rem 0;
      min-height: 80px; /* Minimum banner height */
    }

    .banner-content {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: repeat(4, 1fr); /* 4 rows: nav buttons + 3 rows of links */
      gap: 0.2rem;
      padding: 0 1rem;
      max-width: 100%;
      min-height: 80px;
    }

    .banner-separator {
      display: none;
    }

    .banner-link {
      font-size: clamp(14px, 3.5vw, 16px);
      min-font-size: 14px;
      text-align: center;
      padding: 0.2rem;
      min-height: 24px;
    }

    /* Show mobile navigation buttons and style them */
    .mobile-nav-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--color-green);
      font-family: 'Michroma', sans-serif;
      font-size: clamp(14px, 3.5vw, 16px);
      font-weight: 400;
      letter-spacing: clamp(1px, 0.3vw, 2px);
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      padding: 0.5rem;
      min-height: 24px;
      /* Force navigation buttons to appear in first row */
      order: -1;
    }

    .mobile-nav-btn:hover {
      color: var(--color-green);
      text-shadow: 0 0 8px rgba(66, 204, 93, 0.5);
    }

    .mobile-nav-btn svg {
      width: 20px;
      height: 20px;
    }

    /* Center impressum on mobile */
    .impressum-link {
      grid-column: 1 / -1;
      width: 100%;
      text-align: center;
    }

    /* Hide the floating stack navigation completely on mobile */
    .stack-navigation {
      display: none !important;
    }
    
    .nav-arrow {
      min-width: 40px;
      min-height: 40px;
    }
  }

  /* Adjust main container to account for banner */
  .viewer-container {
    height: calc(100vh - 60px);
  }

  @media (max-width: 768px) {
    .viewer-container {
      height: calc(100vh - 120px); /* Account for taller mobile banner */
    }
  }

  /* Stack navigation arrows */
  .stack-navigation {
    position: fixed;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 1rem;
    z-index: 1000;
  }

  .nav-arrow {
    background: transparent;
    border: none;
    color: var(--color-green);
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .nav-arrow:hover {
    transform: scale(1.2);
  }

  @media (max-width: 768px) {
    .stack-navigation {
      bottom: 120px; /* Account for taller banner on mobile */
    }
  }
</style>

<script>
//=============================================================================
// Type Declarations and Imports
//=============================================================================
interface Intersection {
    distance: number;
    point: THREE.Vector3;
    face: THREE.Face | null;
    faceIndex: number | null;
    instanceId?: number;
    object: THREE.Object3D;
}

import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';

//=============================================================================
// Scene Setup
//=============================================================================
// Crosshair cursor tracking
const crosshair = document.getElementById('crosshair');
const speakerSelectorHint = document.getElementById('speakerSelectorHint');
const viewerContainer = document.querySelector('.viewer-container');

if (crosshair && viewerContainer) {
    viewerContainer.addEventListener('mousemove', (event) => {
        const rect = viewerContainer.getBoundingClientRect();
        const x = event.clientX;
        const y = event.clientY;
        
        // Check if mouse is over an interactive element
        const elementUnderMouse = document.elementFromPoint(x, y);
        const isOverInteractive = elementUnderMouse && (
            elementUnderMouse.tagName === 'BUTTON' ||
            elementUnderMouse.tagName === 'A' ||
            elementUnderMouse.classList.contains('nav-arrow') ||
            elementUnderMouse.classList.contains('banner-link') ||
            elementUnderMouse.classList.contains('main-heading') ||
            elementUnderMouse.classList.contains('overlay') ||
            elementUnderMouse.classList.contains('bottom-banner') ||
            elementUnderMouse.closest('button') ||
            elementUnderMouse.closest('.nav-arrow') ||
            elementUnderMouse.closest('.banner-link') ||
            elementUnderMouse.closest('.main-heading') ||
            elementUnderMouse.closest('.overlay') ||
            elementUnderMouse.closest('.bottom-banner')
        );
        
        crosshair.style.left = x + 'px';
        crosshair.style.top = y + 'px';
        
        // Position speaker selector hint relative to crosshair
        if (speakerSelectorHint) {
            speakerSelectorHint.style.left = x + 'px';
            speakerSelectorHint.style.top = y + 'px';
        }
        
        // Hide crosshair if over interactive elements
        if (isOverInteractive) {
            crosshair.style.opacity = '0';
            if (speakerSelectorHint) {
                speakerSelectorHint.style.opacity = '0';
            }
        } else {
            crosshair.style.opacity = '1';
            // Only handle 3D hover if NOT interfering with UI
            handleHover(x, y);
        }
    });
    
    viewerContainer.addEventListener('mouseleave', () => {
        crosshair.style.opacity = '0';
        if (speakerSelectorHint) {
            speakerSelectorHint.style.opacity = '0';
        }
    });
    
    viewerContainer.addEventListener('mouseenter', () => {
        crosshair.style.opacity = '1';
    });
}

// Hide speaker selector hint after 5 seconds (only on fresh page load)
if (performance.navigation && performance.navigation.type === performance.navigation.TYPE_NAVIGATE) {
    // Fresh page load (not back/forward or refresh)
    setTimeout(() => {
        if (speakerSelectorHint) {
            speakerSelectorHint.classList.add('fade-out');
        }
    }, 5000);
} else {
    // Navigation or back button - hide immediately
    if (speakerSelectorHint) {
        speakerSelectorHint.style.display = 'none';
    }
}

// Canvas
const canvas = document.querySelector('canvas.webgl');
if (!canvas) throw new Error('Canvas not found');

// Scene
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x383e42); // RAL 7016 Anthracite Grey

// Sizes
const sizes = {
    width: window.innerWidth,
    height: window.innerHeight
};

// Camera configuration
const cameraY = 1400; // Camera height (halfway between original 1200 and 1600)
const cameraPitchDeg = -10; // camera pitch angle in degrees
const camera = new THREE.PerspectiveCamera(65, sizes.width / sizes.height, 0.1, 5000); // FOV halfway between 55 and 75
camera.position.set(0, cameraY, 3000); // Distance halfway between original 2500 and 3500
camera.lookAt(0, 5000, 0);
scene.add(camera);

// Create camera target for consistent orientation
const cameraTarget = new THREE.Vector3();
const cameraPitchRad = THREE.MathUtils.degToRad(cameraPitchDeg);

// Renderer
const renderer = new THREE.WebGLRenderer({
    canvas: canvas as HTMLCanvasElement,
    antialias: true,
});
renderer.setSize(sizes.width, sizes.height);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
scene.background = new THREE.Color(0x383e42); // RAL 7016 Anthracite Grey

// Lights
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const spotLight = new THREE.SpotLight(0xffffff, 3);
spotLight.castShadow = true;
spotLight.angle = Math.PI / 3;
spotLight.penumbra = 0.2;
spotLight.decay = 0.1;
spotLight.distance = 5000;
spotLight.position.set(camera.position.x + 50, camera.position.y + 50, camera.position.z);
spotLight.target.position.set(0, 0, 0);
scene.add(spotLight);
scene.add(spotLight.target);

// Configure shadow properties
spotLight.shadow.mapSize.width = 2048;
spotLight.shadow.mapSize.height = 2048;
spotLight.shadow.camera.near = 1;
spotLight.shadow.camera.far = 2000;

// Ground plane
const groundGeometry = new THREE.PlaneGeometry(40000, 80000);
const groundMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x97A7B2, // vvvvvvvvvyxvnhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhb10% darker than original A8BAC6
    roughness: 0.8,
    metalness: 0.1 
});
const groundPlane = new THREE.Mesh(groundGeometry, groundMaterial);
groundPlane.rotation.x = -Math.PI / 2; // Rotate to be horizontal
groundPlane.position.y = 0; // At ground level
groundPlane.receiveShadow = true;
scene.add(groundPlane);



//=============================================================================
// State Management
//=============================================================================
// Interaction state
const mousePanSpeed = 200.0; // world units per pixel for mouse (2x faster than touch)
const touchPanSpeed = 100.0; // world units per pixel for touch (current speed)
const panDamping = 6.0; // damping rate per second
const dragThreshold = 4; // pixels
const selectionOffset = 50; // distance objects move forward/back when selected
const clock = new THREE.Clock();

// State variables
let isPanning = false;
let lastPanX = 0;
let isDragging = false;
let totalDragMovement = 0;
let panVelocity = 0;

// Selection state
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();
const clickableObjects: THREE.Object3D[] = []; // For direct model interaction
let selectedObject: THREE.Object3D | null = null;
let hoveredObject: THREE.Object3D | null = null;

//=============================================================================
// Outline Management
//=============================================================================
function applySelectionMaterial(targetObject: THREE.Object3D) {
    targetObject.traverse((child) => {
        if (child instanceof THREE.LineSegments) {
            child.material = selectedEdgeMaterial;
        }
    });
}

function removeSelectionMaterial(targetObject: THREE.Object3D) {
    targetObject.traverse((child) => {
        if (child instanceof THREE.LineSegments) {
            child.material = edgeMaterial;
        }
    });
}

function handleHover(clientX: number, clientY: number) {
    if (!canvas) return;
    
    const rect = canvas.getBoundingClientRect();
    pointer.x = ((clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = -((clientY - rect.top) / rect.height) * 2 + 1;

    raycaster.setFromCamera(pointer, camera);

    // Find closest intersection - check clickable objects
    let closestIntersection: THREE.Intersection | null = null;
    let minDistance = Infinity;

    for (const object of clickableObjects) {
        const intersects = raycaster.intersectObject(object, true);
        if (intersects.length > 0 && intersects[0].distance < minDistance) {
            closestIntersection = intersects[0];
            minDistance = intersects[0].distance;
        }
    }

    if (!closestIntersection) {
        if (hoveredObject && hoveredObject !== selectedObject) {
            removeSelectionMaterial(hoveredObject);
            // Re-apply if it was somehow selected but logic got messed up? No, strict check.
            hoveredObject = null;
            document.body.style.cursor = 'default';
        }
        return;
    }

    let hitObject = closestIntersection.object;
    let clickableParent: THREE.Object3D | null = null;
    
    // Walk up the hierarchy to find the clickable object
    let current: THREE.Object3D | null = hitObject;
    while (current) {
        if (clickableObjects.includes(current)) {
            clickableParent = current;
            break;
        }
        current = current.parent;
    }

    if (clickableParent) {
        if (hoveredObject !== clickableParent) {
            if (hoveredObject && hoveredObject !== selectedObject) {
                removeSelectionMaterial(hoveredObject);
            }
            
            hoveredObject = clickableParent;
            if (hoveredObject !== selectedObject) {
                applySelectionMaterial(hoveredObject);
            }
            document.body.style.cursor = 'pointer';
        }
    } else {
        if (hoveredObject && hoveredObject !== selectedObject) {
            removeSelectionMaterial(hoveredObject);
            hoveredObject = null;
            document.body.style.cursor = 'default';
        }
    }
}

//=============================================================================
// Overlay Management
//=============================================================================
function showOverlay(title: string, description: string, specs?: any) {
    const overlay = document.getElementById('speakerOverlay');
    if (overlay) {
        // Update content
        const titleElement = overlay.querySelector('h2');
        
        if (titleElement) titleElement.textContent = title;
        
        // Show top 3 specs if available
        const specsElement = overlay.querySelector('.specs') as HTMLElement;
        if (specsElement) {
            if (specs && typeof specs === 'object') {
                const specEntries = Object.entries(specs);
                
                if (specEntries.length > 0) {
                    // Get first 3 specs
                    const top3Specs = specEntries.slice(0, 3);
                    
                    let specsHTML = '';
                    top3Specs.forEach(([key, value], index) => {
                        const formattedKey = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                        specsHTML += `<p><strong style="font-family: 'Michroma', sans-serif !important; letter-spacing: 1px !important; color: white !important; font-size: 0.98rem !important; font-weight: 400 !important;">${formattedKey}</strong></p>`;
                        specsHTML += `<p>${value}</p>`;
                        // Add empty line between stats (but not after the last one)
                        if (index < top3Specs.length - 1) {
                            specsHTML += `<p style="margin: 0; line-height: 0.5;">&nbsp;</p>`;
                        }
                    });
                    
                    specsElement.innerHTML = specsHTML;
                    specsElement.style.display = 'block';
                } else {
                    specsElement.innerHTML = '';
                    specsElement.style.display = 'none';
                }
            } else {
                specsElement.innerHTML = '';
                specsElement.style.display = 'none';
            }
        }
        
        overlay.classList.add('visible');
    }
}

function hideOverlay() {
    const overlay = document.getElementById('speakerOverlay');
    if (overlay) {
        overlay.classList.remove('visible');
    }
}

//=============================================================================
// Selection Handler
//=============================================================================
function handleSelection(event: MouseEvent) {
    if (!canvas) return;
    
    const rect = canvas.getBoundingClientRect();
    pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    raycaster.setFromCamera(pointer, camera);

    // Find closest intersection - check clickable objects
    let closestIntersection: Intersection | null = null;
    let minDistance = Infinity;

    // Check regular clickable objects (speaker/subwoofer system)
    for (const object of clickableObjects) {
        const intersects = raycaster.intersectObject(object, true) as Intersection[]; // recursive for all children
        if (intersects.length > 0 && intersects[0].distance < minDistance) {
            closestIntersection = intersects[0];
            minDistance = intersects[0].distance;
        }
    }

    // If no intersection found, deselect current selection
    if (!closestIntersection) {
        if (selectedObject) {
            // Handle Object3D system
            selectedObject.position.z -= selectionOffset;
            removeSelectionMaterial(selectedObject);
            selectedObject = null;
        }
        hideOverlay();
        return;
    }

    // Handle new Object3D system (speakers/subwoofers)
    // Check if the hit object or its parent is in clickableObjects
    let hitObject = closestIntersection.object;
    let clickableParent: THREE.Object3D | null = null;
    
    // Walk up the hierarchy to find the clickable object
    let current: THREE.Object3D | null = hitObject;
    while (current) {
        if (clickableObjects.includes(current)) {
            clickableParent = current;
            break;
        }
        current = current.parent;
    }
    
    if (clickableParent) {
        console.log('Click detected on object:', clickableParent);

        if (selectedObject === clickableParent) {
            hideOverlay();
            if (selectedObject) {
                selectedObject.position.z -= selectionOffset;
                removeSelectionMaterial(selectedObject);
            }
            selectedObject = null;
            return;
        }

        // Deselect previous selection
        if (selectedObject) {
            selectedObject.position.z -= selectionOffset;
            removeSelectionMaterial(selectedObject);
        }

        // Select new object
        selectedObject = clickableParent;
        clickableParent.position.z += selectionOffset;
        
        // Apply green outline to selected object
        applySelectionMaterial(clickableParent);
        
        // Show overlay using metadata from the GLTF file first, then fallback to config
        let modelMetadata: any = null;
        
        // Try to get metadata from GLTF userData
        if (clickableParent.userData && Object.keys(clickableParent.userData).length > 0) {
            modelMetadata = clickableParent.userData;
        }
        
        // Fallback to speakerConfig if no GLTF metadata found
        const speakerConfig = (clickableParent as any).speakerConfig;
        
        if (modelMetadata && (modelMetadata.speakerType || modelMetadata.name)) {
            // Use GLTF metadata with speakerType as heading
            const heading = modelMetadata.speakerType || modelMetadata.name || "Unknown";
            const description = modelMetadata.description || "No description";
            const specs = modelMetadata.specs;
            
            showOverlay(heading, description, specs);
        } else if (speakerConfig) {
            // Use speakerConfig as fallback with same structure
            const heading = speakerConfig.speakerType || speakerConfig.name || "Unknown";
            const description = speakerConfig.description || "No description";
            const specs = speakerConfig.specs;
            
            showOverlay(heading, description, specs);
        } else {
            // Final fallback
            showOverlay("Speaker", "Audio equipment");
        }
        return;
    }
}

//=============================================================================
// Event Handlers
//=============================================================================
// Overlay controls
if (typeof document !== 'undefined') {
    const closeButton = document.querySelector('.close-button');
    const overlay = document.getElementById('speakerOverlay');
    const actionButton = document.querySelector('.action-button');
    const detailButton = document.getElementById('detailButton');

    if (closeButton) {
        closeButton.addEventListener('click', () => {
            hideOverlay();
        });
    }

    if (overlay) {
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                hideOverlay();
            }
        });
    }

    if (actionButton) {
        actionButton.addEventListener('click', () => {
            console.log('More details clicked for selected speaker');
            // Add your action here
        });
    }

    if (detailButton) {
        detailButton.addEventListener('click', () => {
            // Get the selected speaker data
            let speakerData: any = null;
            if (selectedObject && selectedObject.userData) {
                speakerData = selectedObject.userData;
            } else if (selectedObject && (selectedObject as any).speakerConfig) {
                speakerData = (selectedObject as any).speakerConfig;
            }
            
            if (speakerData) {
                // Store speaker data in sessionStorage for the detail page
                sessionStorage.setItem('speakerDetail', JSON.stringify(speakerData));
                // Navigate to detail page
                window.location.href = '/speaker-detail';
            }
        });
    }
}

// Window resize
window.addEventListener('resize', () => {
    sizes.width = window.innerWidth;
    sizes.height = window.innerHeight;

    camera.aspect = sizes.width / sizes.height;
    camera.updateProjectionMatrix();

    renderer.setSize(sizes.width, sizes.height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
});

// Mouse events
canvas?.addEventListener('mousedown', (event: Event) => {
    const mouseEvent = event as MouseEvent;
    if (mouseEvent.button === 0) {
        isDragging = true;
        totalDragMovement = 0;
        lastPanX = mouseEvent.clientX;
    }
});

window.addEventListener('mousemove', (event: Event) => {
    const mouseEvent = event as MouseEvent;
    if (isDragging) {
        const deltaX = mouseEvent.clientX - lastPanX;
        totalDragMovement += Math.abs(deltaX);

        if (totalDragMovement > dragThreshold) {
            isPanning = true;
            isTransitioning = false; // Cancel auto-transition when user manually pans
            panVelocity = -deltaX * mousePanSpeed; // Using faster mouse speed
        }

        lastPanX = mouseEvent.clientX;
    }
});

window.addEventListener('mouseup', (event: Event) => {
    const mouseEvent = event as MouseEvent;
    if (mouseEvent.button === 0) {
        if (!isPanning && isDragging) {
            handleSelection(mouseEvent);
        }
        isDragging = false;
        isPanning = false;
    }
});

// Touch events for mobile/tablet support
canvas?.addEventListener('touchstart', (event: Event) => {
    const touchEvent = event as TouchEvent;
    event.preventDefault(); // Prevent scrolling
    if (touchEvent.touches.length === 1) {
        isDragging = true;
        totalDragMovement = 0;
        lastPanX = touchEvent.touches[0].clientX;
    }
});

canvas?.addEventListener('touchmove', (event: Event) => {
    const touchEvent = event as TouchEvent;
    event.preventDefault(); // Prevent scrolling
    if (isDragging && touchEvent.touches.length === 1) {
        const deltaX = touchEvent.touches[0].clientX - lastPanX;
        totalDragMovement += Math.abs(deltaX);

        if (totalDragMovement > dragThreshold) {
            isPanning = true;
            isTransitioning = false; // Cancel auto-transition when user manually pans
            panVelocity = -deltaX * touchPanSpeed; // Using touch speed
        }

        lastPanX = touchEvent.touches[0].clientX;
    }
});

canvas?.addEventListener('touchend', (event: Event) => {
    const touchEvent = event as TouchEvent;
    event.preventDefault(); // Prevent scrolling
    if (!isPanning && isDragging && touchEvent.changedTouches.length === 1) {
        // Convert touch to mouse-like event for selection
        const touch = touchEvent.changedTouches[0];
        const fakeMouseEvent = {
            clientX: touch.clientX,
            clientY: touch.clientY,
            button: 0
        } as MouseEvent;
        handleSelection(fakeMouseEvent);
    }
    isDragging = false;
    isPanning = false;
});

// Wheel/trackpad scroll event for horizontal panning
window.addEventListener('wheel', (event: WheelEvent) => {
    // Check for horizontal scroll (trackpad swipe or shift+scroll)
    if (Math.abs(event.deltaX) > Math.abs(event.deltaY)) {
        event.preventDefault(); // Prevent page scroll
        
        // Apply velocity from horizontal scroll
        // Positive deltaX = scroll right, negative = scroll left
        // We want camera to move in same direction, so negate it
        const scrollSpeed = 10.0; // 5x faster (500% of original 2.0)
        panVelocity = event.deltaX * scrollSpeed;
        isPanning = true;
        isTransitioning = false; // Cancel auto-transition when user manually scrolls
    }
}, { passive: false });

//=============================================================================
// Model Loading
//=============================================================================
const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('/draco/');

const gltfLoader = new GLTFLoader();
gltfLoader.setDRACOLoader(dracoLoader);

// Function to properly position models on ground
function positionModelOnGround(model: THREE.Object3D, x: number, z: number, rotationX: number = 0, rotationY: number = 0, rotationZ: number = 0) {
    // Get bounding box
    const box = new THREE.Box3().setFromObject(model);
    
    // Place bottom at Y=0 (ground level) 
    const yPos = -box.min.y;
    model.position.set(x, yPos, z);
    model.rotation.set(rotationX, rotationY, rotationZ);
    model.scale.set(1, 1, 1);
    
    // Set up wireframe rendering with EdgesGeometry
    model.traverse((child: THREE.Object3D) => {
        if ((child as THREE.Mesh).isMesh && (child as THREE.Mesh).geometry) {
            const mesh = child as THREE.Mesh;
            
            // Hide the original mesh
            mesh.visible = false;
            
            // Create edges geometry from the mesh
            const edges = new THREE.EdgesGeometry(mesh.geometry, 15); // 15 degree threshold for edge detection
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x42cc5d, // Green color for edges
                linewidth: 1
            });
            const lineSegments = new THREE.LineSegments(edges, lineMaterial);
            
            // Copy the mesh's transformation
            lineSegments.position.copy(mesh.position);
            lineSegments.rotation.copy(mesh.rotation);
            lineSegments.scale.copy(mesh.scale);
            
            // Add the wireframe to the parent
            if (mesh.parent) {
                mesh.parent.add(lineSegments);
            }
        }
    });
    
    return box.max.y - box.min.y; // Return height for stacking
}

// Speaker configuration - loaded from external config files
// Individual speaker configs: /config/speakers/[name].json + /[name].glb
// Positioning config: src/config/positioning.json

// Get the data passed from frontmatter via window
const {positioningData, speakerConfigs} = (window as any).speakerData;
const stacks = positioningData.stacks;

console.log('=== ThreeViewer Debug Info ===');
console.log('Window speakerData available:', !!(window as any).speakerData);
console.log('Number of stacks:', stacks.length);
console.log('Speaker configs available:', Object.keys(speakerConfigs).length);
console.log('Stack names:', stacks.map((s: any) => s.name));
console.log('Speaker config IDs:', Object.keys(speakerConfigs));

// Model cache to avoid loading the same model multiple times
const modelCache = new Map<string, THREE.Group>();
const speakerMetadataCache = new Map<string, any>();
const edgeGeometryCache = new Map<THREE.BufferGeometry, THREE.EdgesGeometry>();

// Collect all unique speaker models from stacks
const uniqueModels = new Set<string>();
stacks.forEach(stack => {
    stack.speakers.forEach((speaker: any) => {
        uniqueModels.add(speaker.model);
    });
});

// Also add all individual speakers from config (standalone speakers not in stacks)
Object.keys(speakerConfigs).forEach(speakerId => {
    uniqueModels.add(speakerId);
});

console.log('Unique models to load:', Array.from(uniqueModels));
console.log('=== Model Loading Debug ===');

// Track loading progress
let loadedModels = 0;
const totalModels = uniqueModels.size;
console.log('Total models to load:', totalModels);

const loadingScreen = document.getElementById('loadingScreen');
const loadingProgress = document.getElementById('loadingProgress');
const loadingText = document.getElementById('loadingText');

// Stack positioning
let currentStackIndex = 0; // Will be set to middle stack after initialization
const stackPositions: number[] = [];
let cameraTargetX = 0;
const cameraTransitionSpeed = 3.0; // Smooth camera movement for arrow navigation
let isTransitioning = false; // Flag to control arrow button transitions

// Shared materials for new rendering style
const solidMaterial = new THREE.MeshBasicMaterial({
    color: 0x383e42, // RAL 7016 Anthracite Grey (match scene background)
    polygonOffset: true,
    polygonOffsetFactor: 0.5,
    polygonOffsetUnits: 0.5
});

const edgeMaterial = new THREE.LineBasicMaterial({ 
    color: 0x000000, // Black color for edges
    linewidth: 1.5
});

const selectedEdgeMaterial = new THREE.LineBasicMaterial({
    color: 0xffffff, // White for selected edges
    linewidth: 1.5
});

// Function to create the two-pass render object from a model with caching
function createRenderGroupFromModel(model: THREE.Object3D): THREE.Group {
    // Clone the entire hierarchy to preserve structure (parent/child transforms)
    const renderGroup = model.clone() as THREE.Group;
    
    renderGroup.traverse((child: THREE.Object3D) => {
        if ((child as THREE.Mesh).isMesh) {
            const mesh = child as THREE.Mesh;
            const geometry = mesh.geometry;
            
            // 1. Apply solid material to the mesh
            mesh.material = solidMaterial;

            // 2. Create the black edges
            if (geometry) {
                // Check cache for edges geometry
                let edges = edgeGeometryCache.get(geometry);
                if (!edges) {
                    edges = new THREE.EdgesGeometry(geometry, 15); // 15 degree threshold
                    edgeGeometryCache.set(geometry, edges);
                }
                
                const lineSegments = new THREE.LineSegments(edges, edgeMaterial);
                
                // Add edges as a child of the mesh so it inherits all transforms
                mesh.add(lineSegments);
            }
        }
    });
    
    return renderGroup;
}

function updateLoadingProgress() {
    const progress = (loadedModels / totalModels) * 100;
    console.log(`Loading progress: ${loadedModels}/${totalModels} (${progress.toFixed(1)}%)`);
    
    if (loadingProgress) {
        loadingProgress.style.width = `${progress}%`;
    }
    if (loadingText) {
        loadingText.textContent = `Loading models: ${loadedModels}/${totalModels}`;
    }
    
    // Hide loading screen when complete
    if (loadedModels === totalModels) {
        console.log('All models loaded, hiding loading screen...');
        setTimeout(() => {
            if (loadingScreen) {
                loadingScreen.classList.add('hidden');
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                    console.log('Initializing stacks...');
                    initializeStacks();
                }, 500);
            }
        }, 300);
    }
}

// Function to load individual speaker config 
function loadSpeakerConfig(modelName: string): any {
    const config = speakerConfigs[modelName as keyof typeof speakerConfigs];
    if (config) {
        speakerMetadataCache.set(modelName, config);
        return config;
    } else {
        console.error(`Speaker config not found: ${modelName}`);
        const fallback = {
            name: modelName,
            description: "Unknown speaker",
            specs: {}
        };
        speakerMetadataCache.set(modelName, fallback);
        return fallback;
    }
}

// Load all speaker models and configs
async function loadAllSpeakers() {
    console.log('=== loadAllSpeakers() called ===');
    console.log('Models to load:', Array.from(uniqueModels));
    
    const loadPromises = Array.from(uniqueModels).map(async (modelName) => {
        console.log(`Starting to load model: ${modelName}`);
        
        try {
            // Load config synchronously and model asynchronously
            const config = loadSpeakerConfig(modelName);
            
            await new Promise<THREE.Group>((resolve, reject) => {
                const modelPath = `/${modelName}.glb`;
                console.log(`Loading GLTF file: ${modelPath}`);
                
                // Check if model is already in cache
                if (modelCache.has(modelPath)) {
                    console.log(`Using cached model: ${modelPath}`);
                    resolve(modelCache.get(modelPath)!);
                    return;
                }
                
                // Load model
                gltfLoader.load(modelPath,
                    (gltf) => {
                        console.log(`Successfully loaded: ${modelPath}`);
                        const templateModel = gltf.scene;
                        modelCache.set(modelPath, templateModel);
                        resolve(templateModel);
                        console.log(`Loaded model: ${modelPath}`);
                    },
                    (progress) => {
                        if (progress.total > 0 && loadingText) {
                            const percent = (progress.loaded / progress.total) * 100;
                            console.log(`Loading ${modelName}: ${percent.toFixed(1)}%`);
                            loadingText.textContent = `Loading ${config.name || modelName}: ${Math.round(percent)}%`;
                        }
                    },
                    function (error: any) {
                        console.error(`Load Error ${modelName}:`, error);
                        console.error(`Failed to load: ${modelPath}`);
                        reject(error);
                    }
                );
            });
            
            loadedModels++;
            updateLoadingProgress();
            console.log(`Completed ${loadedModels}/${totalModels}: ${modelName}`);
        } catch (error) {
            console.error(`Failed to load speaker: ${modelName}`, error);
            loadedModels++;
            updateLoadingProgress();
        }
    });
    
    await Promise.all(loadPromises);
}

// Start loading
console.log('Starting to load speakers...');
console.log('Total models detected:', totalModels);
console.log('Unique models array:', Array.from(uniqueModels));

if (totalModels === 0) {
    console.log('No models to load, initializing immediately...');
    initializeStacks();
} else {
    console.log('Loading', totalModels, 'models...');
    loadAllSpeakers();
}

// Initialize all stacks after models are loaded
function initializeStacks() {
    let currentX = 0;
    
    stacks.forEach((stack, stackIndex) => {
        stackPositions.push(currentX);
        
        stack.speakers.forEach((speaker: any) => {
            const modelName = speaker.model;
            const modelPath = `/${modelName}.glb`;
            const templateModel = modelCache.get(modelPath);
            const speakerConfig = speakerMetadataCache.get(modelName);
            
            if (!templateModel) {
                console.error(`Model not found in cache: ${modelPath}`);
                return;
            }
            
            if (!speakerConfig) {
                console.error(`Speaker config not found: ${modelName}`);
                return;
            }
            
            // Create render group
            const renderGroup = createRenderGroupFromModel(templateModel);
            
            // Position relative to stack origin
            const box = new THREE.Box3().setFromObject(templateModel);
            
            if (speaker.onGround) {
                const yPos = -box.min.y;
                renderGroup.position.set(currentX + speaker.x, yPos, speaker.z);
            } else {
                renderGroup.position.set(currentX + speaker.x, speaker.y, speaker.z);
            }
            
            renderGroup.rotation.set(
                speaker.rotationX || 0,
                speaker.rotationY || 0,
                speaker.rotationZ || 0
            );
            
            // Add metadata using the loaded config
            (renderGroup as any).stackIndex = stackIndex;
            renderGroup.userData = {
                speakerType: speakerConfig.name,
                name: speakerConfig.name,
                description: speakerConfig.description,
                specs: speakerConfig.specs,
                modelPath: modelPath,
                category: speakerConfig.category,
                type: speakerConfig.type,
                weight: speakerConfig.weight,
                dimensions: speakerConfig.dimensions,
                images: speakerConfig.images // Pass images array
            };
            
            scene.add(renderGroup);
            clickableObjects.push(renderGroup);
        });
        
        // Move to next stack position
        currentX += stack.spacing || 3000;
    });
    
    // Calculate middle stack index and position camera on it
    const middleStackIndex = Math.floor(stacks.length / 2);
    currentStackIndex = middleStackIndex;
    cameraTargetX = stackPositions[middleStackIndex];
    
    // Set initial camera position to center on middle stack
    camera.position.x = stackPositions[middleStackIndex];
    
    console.log(`Positioned camera on middle stack ${middleStackIndex} of ${stacks.length} stacks at x=${stackPositions[middleStackIndex]}`);
    
    // Add individual speakers not in stacks
    addIndividualSpeakers(currentX);
}

function addIndividualSpeakers(startX: number) {
    const stackModelIds = new Set<string>();
    
    // Collect all speaker IDs already used in stacks
    stacks.forEach(stack => {
        stack.speakers.forEach((speaker: any) => {
            stackModelIds.add(speaker.model);
        });
    });
    
    // Find speakers not in any stack
    const individualSpeakers = Object.keys(speakerConfigs).filter(speakerId => 
        !stackModelIds.has(speakerId)
    );
    
    console.log('Individual speakers to add:', individualSpeakers);
    
    // Position individual speakers to the right of stacks
    let currentX = startX + 3000; // Some spacing after stacks
    
    individualSpeakers.forEach((speakerId, index) => {
        const modelPath = `/${speakerId}.glb`;
        const templateModel = modelCache.get(modelPath);
        const speakerConfig = speakerMetadataCache.get(speakerId);
        
        if (!templateModel) {
            console.error(`Individual model not found in cache: ${modelPath}`);
            return;
        }
        
        if (!speakerConfig) {
            console.error(`Individual speaker config not found: ${speakerId}`);
            return;
        }
        
        // Create render group
        const renderGroup = createRenderGroupFromModel(templateModel);
        
        // Position individual speakers in a row
        const box = new THREE.Box3().setFromObject(templateModel);
        const yPos = -box.min.y;
        renderGroup.position.set(currentX, yPos, 0);
        renderGroup.rotation.y = 0;
        
        // Add metadata
        (renderGroup as any).stackIndex = -1; // Mark as individual speaker
        renderGroup.userData = {
            speakerType: speakerConfig.name,
            name: speakerConfig.name,
            description: speakerConfig.description,
            specs: speakerConfig.specs,
            modelPath: modelPath,
            category: speakerConfig.category,
            type: speakerConfig.type,
            weight: speakerConfig.weight,
            dimensions: speakerConfig.dimensions,
            images: speakerConfig.images // Pass images array
        };
        
        scene.add(renderGroup);
        clickableObjects.push(renderGroup);
        
        // Space out individual speakers
        currentX += 800;
    });
}

// Stack navigation functions
function getCurrentClosestStack(): number {
    // Find which stack is closest to current camera position
    let closestIndex = 0;
    let minDistance = Math.abs(camera.position.x - stackPositions[0]);
    
    for (let i = 1; i < stackPositions.length; i++) {
        const distance = Math.abs(camera.position.x - stackPositions[i]);
        if (distance < minDistance) {
            minDistance = distance;
            closestIndex = i;
        }
    }
    
    return closestIndex;
}

function navigateToStack(direction: number) {
    // currentStackIndex is already updated continuously in the animation loop
    // So we just use it directly to find the next stack
    let nextIndex = currentStackIndex + direction;
    
    // Cycle through stacks (wrap around)
    if (nextIndex < 0) {
        nextIndex = stacks.length - 1;
    } else if (nextIndex >= stacks.length) {
        nextIndex = 0;
    }
    
    currentStackIndex = nextIndex;
    cameraTargetX = stackPositions[nextIndex];
    isTransitioning = true; // Enable smooth transition
}

// Navigation button event listeners
if (typeof document !== 'undefined') {
    const navLeft = document.getElementById('navLeft');
    const navRight = document.getElementById('navRight');
    const navLeftMobile = document.getElementById('navLeftMobile');
    const navRightMobile = document.getElementById('navRightMobile');
    
    if (navLeft) {
        navLeft.addEventListener('click', () => {
            navigateToStack(-1); // Navigate to previous stack
        });
    }
    
    if (navRight) {
        navRight.addEventListener('click', () => {
            navigateToStack(1); // Navigate to next stack
        });
    }

    // Mobile navigation button event listeners
    if (navLeftMobile) {
        navLeftMobile.addEventListener('click', () => {
            navigateToStack(-1); // Navigate to previous stack
        });
    }
    
    if (navRightMobile) {
        navRightMobile.addEventListener('click', () => {
            navigateToStack(1); // Navigate to next stack
        });
    }

    // Products link click handlers
    const productsLinks = document.querySelectorAll('.products-link');
    productsLinks.forEach(link => {
        link.addEventListener('click', () => {
            window.location.href = '/products';
        });
    });

    // Projects link click handlers
    const projectsLinks = document.querySelectorAll('.projects-link');
    projectsLinks.forEach(link => {
        link.addEventListener('click', () => {
            window.location.href = '/projects';
        });
    });

    // Contact link click handlers
    const contactLinks = document.querySelectorAll('.contact-link');
    contactLinks.forEach(link => {
        link.addEventListener('click', () => {
            window.location.href = '/contact';
        });
    });

    // About link click handlers
    const aboutLinks = document.querySelectorAll('.about-link');
    aboutLinks.forEach(link => {
        link.addEventListener('click', () => {
            window.location.href = '/about';
        });
    });

    // Impressum link click handlers
    const impressumLinks = document.querySelectorAll('.impressum-link');
    impressumLinks.forEach(link => {
        link.addEventListener('click', () => {
            window.location.href = '/impressum';
        });
    });
}

//=============================================================================
// Animation Loop
//=============================================================================
function animate() {
    const deltaTime = clock.getDelta();

    // Apply velocity damping when not actively panning
    if (!isPanning) {
        panVelocity *= Math.exp(-panDamping * deltaTime);
    }

    // Update camera position from velocity
    camera.position.x += panVelocity * deltaTime;
    
    // Update current stack index based on camera position
    const newClosestStack = getCurrentClosestStack();
    currentStackIndex = newClosestStack;
    
    // Handle different navigation modes
    if (isTransitioning) {
        // Arrow button navigation - smooth transition to exact stack position
        const cameraDiff = cameraTargetX - camera.position.x;
        if (Math.abs(cameraDiff) > 1) {
            camera.position.x += cameraDiff * cameraTransitionSpeed * deltaTime;
        } else {
            camera.position.x = cameraTargetX; // Snap to exact position
            isTransitioning = false;
        }
    } else {
        // Auto-centering for manual navigation (mouse, touch, trackpad)
        const currentStackPosition = stackPositions[currentStackIndex];
        const distanceToStack = Math.abs(camera.position.x - currentStackPosition);
        const velocityMagnitude = Math.abs(panVelocity);
        
        // Auto-center when velocity is low and not manually interacting
        const shouldAutoCenter = !isPanning && velocityMagnitude < 50 && distanceToStack > 10;
        
        if (shouldAutoCenter) {
            const snapDirection = currentStackPosition - camera.position.x;
            
            // Adaptive centering speed based on distance
            let centeringSpeed;
            if (distanceToStack > 1000) {
                // Far away - move quickly
                centeringSpeed = 4.0;
            } else if (distanceToStack > 500) {
                // Medium distance - moderate speed
                centeringSpeed = 2.5;
            } else if (distanceToStack > 100) {
                // Close - slow approach
                centeringSpeed = 1.5;
            } else {
                // Very close - gentle final alignment
                centeringSpeed = 0.8;
            }
            
            const snapMovement = snapDirection * centeringSpeed * deltaTime;
            camera.position.x += snapMovement;
            
            // Final snap when very close to prevent oscillation
            if (distanceToStack < 5) {
                camera.position.x = currentStackPosition;
            }
        }
    }
    
    // Update camera target position and orientation
    cameraTarget.x = camera.position.x;
    const pitchedDir = new THREE.Vector3(0, Math.sin(cameraPitchRad), -Math.cos(cameraPitchRad));
    const lookDistance = 100;
    cameraTarget.copy(camera.position).addScaledVector(pitchedDir, lookDistance);
    camera.lookAt(cameraTarget);

    // Update light position to follow camera
    const backOffset = 20;
    const upOffset = 30;
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    const lightPos = camera.position.clone().add(forward.clone().multiplyScalar(-backOffset)).add(new THREE.Vector3(0, upOffset, 0));
    spotLight.position.copy(lightPos);
    spotLight.target.position.copy(cameraTarget);
    spotLight.target.updateMatrixWorld();

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}

// Start animation after everything is set up
animate();
</script>
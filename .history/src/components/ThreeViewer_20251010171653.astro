---
// ThreeViewer.astro - A Three.js viewer component for Astro
---
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Michroma&family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

<div class="viewer-container">
  <canvas class="webgl"></canvas>
  <div class="overlay" id="speakerOverlay">
    <div class="overlay-content">
      <h3 id="speakerTitle">Studio Monitor</h3>
      <div class="specs">
        <div class="spec-item" id="spec1">35Hz - 20kHz</div>
        <div class="spec-item" id="spec2">150W Power</div>
        <div class="spec-item" id="spec3">8" Woofer, 1" Tweeter</div>
      </div>
    </div>
  </div>
</div>

<style>
  .viewer-container {
    width: 100%;
    height: 100vh;
    margin: 0;
    padding: 0;
    position: relative;
  }
  .webgl {
    width: 100%;
    height: 100%;
  }
  .overlay {
    position: fixed;
    top: 20px;
    right: 20px;
    width: 280px;
    background: transparent;
    border-radius: 10px;
    display: none;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.3s ease, transform 0.3s ease;
    transform: translateX(20px);
  }
  .overlay.visible {
    display: block;
    opacity: 1;
    transform: translateX(0);
  }
  .overlay-content {
    padding: 1.5rem;
    color: white;
    position: relative;
  }
  .specs {
    margin-top: 1rem;
  }
  .spec-item {
    margin: 0.5rem 0;
    padding: 0.4rem 0.8rem;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 0;
    font-size: 0.9rem;
    font-family: 'Roboto', sans-serif;
  }
  h3 {
    color: white;
    margin: 0 0 1rem 0;
    font-size: 1.3rem;
    font-weight: 600;
    font-family: 'Michroma', sans-serif;
  }
</style>

<script>
//=============================================================================
// Type Declarations and Imports
//=============================================================================
interface Intersection {
    distance: number;
    point: THREE.Vector3;
    face: THREE.Face | null;
    faceIndex: number | null;
    instanceId?: number;
    object: THREE.Object3D;
}

import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';

//=============================================================================
// Scene Setup
//=============================================================================
// Canvas
const canvas = document.querySelector('canvas.webgl');
if (!canvas) throw new Error('Canvas not found');

// Scene
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x8c8c8c);

// Sizes
const sizes = {
    width: window.innerWidth,
    height: window.innerHeight
};

// Camera configuration
const cameraY = 800; // Camera height 
const cameraPitchDeg = -5; // camera pitch angle in degrees
const camera = new THREE.PerspectiveCamera(50, sizes.width / sizes.height, 0.1, 5000);
camera.position.set(0, cameraY, 1500);
camera.lookAt(0, 5000, 0);
scene.add(camera);

// Create camera target for consistent orientation
const cameraTarget = new THREE.Vector3();
const cameraPitchRad = THREE.MathUtils.degToRad(cameraPitchDeg);

// Renderer
const renderer = new THREE.WebGLRenderer({
    canvas: canvas as HTMLCanvasElement,
    antialias: true,
});
renderer.setSize(sizes.width, sizes.height);
renderer.shadowMap.enabled = true;
(renderer as any).physicallyCorrectLights = true;
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
scene.background = new THREE.Color(0x8c8c8c);

// Lights
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const spotLight = new THREE.SpotLight(0xffffff, 3);
spotLight.castShadow = true;
spotLight.angle = Math.PI / 4;
spotLight.penumbra = 0.2;
spotLight.decay = 0.1;
spotLight.distance = 5000;
spotLight.position.set(camera.position.x + 50, camera.position.y + 50, camera.position.z);
spotLight.target.position.set(0, 0, 0);
scene.add(spotLight);
scene.add(spotLight.target);

// Configure shadow properties
spotLight.shadow.mapSize.width = 2048;
spotLight.shadow.mapSize.height = 2048;
spotLight.shadow.camera.near = 1;
spotLight.shadow.camera.far = 2000;

// Ground plane
const groundGeometry = new THREE.PlaneGeometry(15000, 30000);
const groundMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x444444,
    roughness: 0.8,
    metalness: 0.1 
});
const groundPlane = new THREE.Mesh(groundGeometry, groundMaterial);
groundPlane.rotation.x = -Math.PI / 2; // Rotate to be horizontal
groundPlane.position.y = 0; // At ground level
groundPlane.receiveShadow = true;
scene.add(groundPlane);

//=============================================================================
// State Management
//=============================================================================
// Interaction state
const mousePanSpeed = 200.0; // world units per pixel for mouse (2x faster than touch)
const touchPanSpeed = 50.0; // world units per pixel for touch (current speed)
const panDamping = 6.0; // damping rate per second
const dragThreshold = 4; // pixels
const selectionOffset = 200; // distance objects move forward/back when selected
const clock = new THREE.Clock();

// State variables
let isPanning = false;
let lastPanX = 0;
let isDragging = false;
let totalDragMovement = 0;
let panVelocity = 0;

// Selection state
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();
const instancedMeshes: THREE.InstancedMesh[] = [];
const clickableObjects: THREE.Object3D[] = []; // For direct model interaction
let selectedMesh: THREE.InstancedMesh | null = null;
let selectedInstance = -1;
let selectedObject: THREE.Object3D | null = null;

//=============================================================================
// Overlay Management
//=============================================================================
function showOverlay(title: string, description: string, specs: Record<string, string>) {
    const overlay = document.getElementById('speakerOverlay');
    if (overlay) {
        // Update content
        const titleElement = overlay.querySelector('h2');
        const descElement = overlay.querySelector('p');
        const specsElement = overlay.querySelector('.specs');
        
        if (titleElement) titleElement.textContent = title;
        if (descElement) descElement.textContent = description;
        
        if (specsElement) {
            specsElement.innerHTML = '';
            Object.entries(specs).forEach(([key, value]) => {
                const specItem = document.createElement('div');
                specItem.className = 'spec-item';
                specItem.innerHTML = `<span class="spec-label">${key}:</span> <span class="spec-value">${value}</span>`;
                specsElement.appendChild(specItem);
            });
        }
        
        overlay.classList.add('visible');
    }
}

function hideOverlay() {
    const overlay = document.getElementById('speakerOverlay');
    if (overlay) {
        overlay.classList.remove('visible');
        setTimeout(() => {
            if (!overlay.classList.contains('visible')) {
                if (selectedMesh && selectedInstance !== -1) {
                    const matrix = new THREE.Matrix4();
                    selectedMesh.getMatrixAt(selectedInstance, matrix);
                    const position = new THREE.Vector3();
                    const quaternion = new THREE.Quaternion();
                    const scale = new THREE.Vector3();
                    matrix.decompose(position, quaternion, scale);
                    position.z -= selectionOffset;
                    matrix.compose(position, quaternion, scale);
                    selectedMesh.setMatrixAt(selectedInstance, matrix);
                    selectedMesh.instanceMatrix.needsUpdate = true;
                    selectedMesh = null;
                    selectedInstance = -1;
                }
            }
        }, 300);
    }
}

//=============================================================================
// Selection Handler
//=============================================================================
function handleSelection(event: MouseEvent) {
    if (!canvas) return;
    
    const rect = canvas.getBoundingClientRect();
    pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    raycaster.setFromCamera(pointer, camera);

    // Find closest intersection - check both instanced meshes and regular objects
    let closestIntersection: Intersection | null = null;
    let minDistance = Infinity;

    // Check instanced meshes (old speaker system if any remain)
    for (const meshItem of instancedMeshes) {
        const intersects = raycaster.intersectObject(meshItem) as Intersection[];
        if (intersects.length > 0 && intersects[0].distance < minDistance) {
            closestIntersection = intersects[0];
            minDistance = intersects[0].distance;
        }
    }

    // Check regular clickable objects (new speaker/subwoofer system)
    for (const object of clickableObjects) {
        const intersects = raycaster.intersectObject(object, true) as Intersection[]; // recursive for all children
        if (intersects.length > 0 && intersects[0].distance < minDistance) {
            closestIntersection = intersects[0];
            minDistance = intersects[0].distance;
        }
    }

    // If no intersection found, deselect current selection
    if (!closestIntersection) {
        if (selectedMesh && selectedInstance !== -1) {
            // Handle old InstancedMesh system
            const matrix = new THREE.Matrix4();
            selectedMesh.getMatrixAt(selectedInstance, matrix);
            const position = new THREE.Vector3();
            const quaternion = new THREE.Quaternion();
            const scale = new THREE.Vector3();
            matrix.decompose(position, quaternion, scale);
            position.z -= selectionOffset;
            matrix.compose(position, quaternion, scale);
            selectedMesh.setMatrixAt(selectedInstance, matrix);
            selectedMesh.instanceMatrix.needsUpdate = true;
            selectedMesh = null;
            selectedInstance = -1;
        }
        if (selectedObject) {
            // Handle new Object3D system
            selectedObject.position.z -= selectionOffset;
            selectedObject = null;
        }
        hideOverlay();
        return;
    }

    // Handle new Object3D system (speakers/subwoofers)
    // Check if the hit object or its parent is in clickableObjects
    let hitObject = closestIntersection.object;
    let clickableParent: THREE.Object3D | null = null;
    
    // Walk up the hierarchy to find the clickable object
    let current: THREE.Object3D | null = hitObject;
    while (current) {
        if (clickableObjects.includes(current)) {
            clickableParent = current;
            break;
        }
        current = current.parent;
    }
    
    if (clickableParent) {
        console.log('Click detected on object:', clickableParent);

        if (selectedObject === clickableParent) {
            hideOverlay();
            if (selectedObject) {
                selectedObject.position.z -= selectionOffset;
            }
            selectedObject = null;
            return;
        }

        // Deselect previous selection
        if (selectedObject) {
            selectedObject.position.z -= selectionOffset;
        }
        if (selectedMesh && selectedInstance !== -1) {
            const matrix = new THREE.Matrix4();
            selectedMesh.getMatrixAt(selectedInstance, matrix);
            const position = new THREE.Vector3();
            const quaternion = new THREE.Quaternion();
            const scale = new THREE.Vector3();
            matrix.decompose(position, quaternion, scale);
            position.z -= selectionOffset;
            matrix.compose(position, quaternion, scale);
            selectedMesh.setMatrixAt(selectedInstance, matrix);
            selectedMesh.instanceMatrix.needsUpdate = true;
            selectedMesh = null;
            selectedInstance = -1;
        }

        // Select new object
        selectedObject = clickableParent;
        clickableParent.position.z += selectionOffset;
        
        // Show overlay using metadata from the object
        const speakerConfig = (clickableParent as any).speakerConfig;
        if (speakerConfig) {
            showOverlay(speakerConfig.name, speakerConfig.description, speakerConfig.specs);
        } else {
            // Fallback for objects without metadata
            showOverlay("Speaker", "Audio equipment", { "Type": "Unknown" });
        }
        return;
    }

    // Handle old InstancedMesh system (if any remain)
    const hitInstanceId = closestIntersection.instanceId;
    if (hitInstanceId === undefined) return;

    const hitMesh = closestIntersection.object as THREE.InstancedMesh;
    console.log('Click detected on instance:', hitInstanceId);

    if (selectedMesh === hitMesh && selectedInstance === hitInstanceId) {
        hideOverlay();
        return;
    }

    if (selectedMesh && selectedInstance !== -1) {
        const prevMatrix = new THREE.Matrix4();
        selectedMesh.getMatrixAt(selectedInstance, prevMatrix);
        const prevPosition = new THREE.Vector3();
        const prevQuaternion = new THREE.Quaternion();
        const prevScale = new THREE.Vector3();
        prevMatrix.decompose(prevPosition, prevQuaternion, prevScale);
        prevPosition.z -= selectionOffset;
        prevMatrix.compose(prevPosition, prevQuaternion, prevScale);
        selectedMesh.setMatrixAt(selectedInstance, prevMatrix);
        selectedMesh.instanceMatrix.needsUpdate = true;
    }

    const newMatrix = new THREE.Matrix4();
    hitMesh.getMatrixAt(hitInstanceId, newMatrix);
    const newPosition = new THREE.Vector3();
    const newQuaternion = new THREE.Quaternion();
    const newScale = new THREE.Vector3();
    newMatrix.decompose(newPosition, newQuaternion, newScale);
    newPosition.z += selectionOffset;
    newMatrix.compose(newPosition, newQuaternion, newScale);
    hitMesh.setMatrixAt(hitInstanceId, newMatrix);
    hitMesh.instanceMatrix.needsUpdate = true;

    selectedMesh = hitMesh;
    selectedInstance = hitInstanceId;
    
    // Show overlay with speaker content
    showOverlay("Speaker", "High-quality studio monitor", {
        "Type": "Active Studio Monitor",
        "Power": "75W + 25W",
        "Frequency Response": "45Hz - 22kHz",
        "Drivers": "6.5\" Woofer + 1\" Tweeter",
        "Connections": "XLR, TRS"
    });
}

//=============================================================================
// Event Handlers
//=============================================================================
// Overlay controls
if (typeof document !== 'undefined') {
    const closeButton = document.querySelector('.close-button');
    const overlay = document.getElementById('speakerOverlay');
    const actionButton = document.querySelector('.action-button');

    if (closeButton) {
        closeButton.addEventListener('click', () => {
            hideOverlay();
        });
    }

    if (overlay) {
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                hideOverlay();
            }
        });
    }

    if (actionButton) {
        actionButton.addEventListener('click', () => {
            console.log('More details clicked for speaker:', selectedInstance);
            // Add your action here
        });
    }
}

// Window resize
window.addEventListener('resize', () => {
    sizes.width = window.innerWidth;
    sizes.height = window.innerHeight;

    camera.aspect = sizes.width / sizes.height;
    camera.updateProjectionMatrix();

    renderer.setSize(sizes.width, sizes.height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
});

// Mouse events
canvas.addEventListener('mousedown', ((event: Event) => {
    const mouseEvent = event as MouseEvent;
    if (mouseEvent.button === 0) {
        isDragging = true;
        totalDragMovement = 0;
        lastPanX = mouseEvent.clientX;
    }
}) as EventListener);

window.addEventListener('mousemove', ((event: Event) => {
    const mouseEvent = event as MouseEvent;
    if (isDragging) {
        const deltaX = mouseEvent.clientX - lastPanX;
        totalDragMovement += Math.abs(deltaX);

        if (totalDragMovement > dragThreshold) {
            isPanning = true;
            panVelocity = -deltaX * mousePanSpeed; // Using faster mouse speed
        }

        lastPanX = mouseEvent.clientX;
    }
}) as EventListener);

window.addEventListener('mouseup', ((event: Event) => {
    const mouseEvent = event as MouseEvent;
    if (mouseEvent.button === 0) {
        if (!isPanning && isDragging) {
            handleSelection(mouseEvent);
        }
        isDragging = false;
        isPanning = false;
    }
}) as EventListener);

// Touch events for mobile/tablet support
canvas.addEventListener('touchstart', ((event: Event) => {
    const touchEvent = event as TouchEvent;
    event.preventDefault(); // Prevent scrolling
    if (touchEvent.touches.length === 1) {
        isDragging = true;
        totalDragMovement = 0;
        lastPanX = touchEvent.touches[0].clientX;
    }
}) as EventListener);

canvas.addEventListener('touchmove', ((event: Event) => {
    const touchEvent = event as TouchEvent;
    event.preventDefault(); // Prevent scrolling
    if (isDragging && touchEvent.touches.length === 1) {
        const deltaX = touchEvent.touches[0].clientX - lastPanX;
        totalDragMovement += Math.abs(deltaX);

        if (totalDragMovement > dragThreshold) {
            isPanning = true;
            panVelocity = -deltaX * touchPanSpeed; // Using touch speed
        }

        lastPanX = touchEvent.touches[0].clientX;
    }
}) as EventListener);

canvas.addEventListener('touchend', ((event: Event) => {
    const touchEvent = event as TouchEvent;
    event.preventDefault(); // Prevent scrolling
    if (!isPanning && isDragging && touchEvent.changedTouches.length === 1) {
        // Convert touch to mouse-like event for selection
        const touch = touchEvent.changedTouches[0];
        const fakeMouseEvent = {
            clientX: touch.clientX,
            clientY: touch.clientY,
            button: 0
        } as MouseEvent;
        handleSelection(fakeMouseEvent);
    }
    isDragging = false;
    isPanning = false;
}) as EventListener);

//=============================================================================
// Model Loading
//=============================================================================
const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('/draco/');

const gltfLoader = new GLTFLoader();
gltfLoader.setDRACOLoader(dracoLoader);

// Function to properly position models on ground
function positionModelOnGround(model: THREE.Object3D, x: number, z: number, rotationY: number = 0) {
    // Center the model
    const box = new THREE.Box3().setFromObject(model);
    const center = new THREE.Vector3();
    box.getCenter(center);
    model.position.sub(center);
    
    // Place bottom at Y=0 (ground level)
    const yPos = -box.min.y;
    model.position.set(x, yPos, z);
    model.rotation.y = rotationY;
    model.scale.set(1, 1, 1);
    
    // Set up shadows
    model.traverse((child: THREE.Object3D) => {
        if ((child as THREE.Mesh).isMesh && (child as THREE.Mesh).geometry) {
            (child as THREE.Mesh).castShadow = true;
            (child as THREE.Mesh).receiveShadow = true;
            
            if ((child as THREE.Mesh).material) {
                if (Array.isArray((child as THREE.Mesh).material)) {
                    ((child as THREE.Mesh).material as THREE.Material[]).forEach(mat => {
                        (mat as any).needsUpdate = true;
                    });
                } else {
                    ((child as THREE.Mesh).material as any).needsUpdate = true;
                }
            }
        }
    });
    
    return box.max.y - box.min.y; // Return height for stacking
}

// Speaker configuration - easily modify these for different setups
const speakerConfigs = [
    {
        modelPath: '/speaker.glb',
        name: 'Studio Monitor',
        description: 'High-quality studio monitor',
        specs: {
            "Type": "Active Studio Monitor",
            "Power": "75W + 25W",
            "Frequency Response": "45Hz - 22kHz",
            "Drivers": "6.5\" Woofer + 1\" Tweeter",
            "Connections": "XLR, TRS"
        },
        instances: [
            // Speaker on top of leftmost sub (at x: -1295)
            { x: -1295, y: 0, z: 0, stackLevel: 2 },
            // Speaker on top of rightmost sub (at x: 1295) 
            { x: 1295, y: 0, z: 0, stackLevel: 2 }
        ]
    },
    {
        modelPath: '/sub.glb',
        name: 'Subwoofer',
        description: 'Bass speaker for low frequencies',
        specs: {
            "Type": "Powered Subwoofer",
            "Power": "500W RMS",
            "Frequency Response": "20Hz - 150Hz",
            "Driver": "15\" Woofer",
            "Connections": "XLR, TRS, RCA"
        },
        instances: [
            // 8 subwoofers in a row across the floor (facing forward, spaced 370 units apart)
            { x: -1295, y: 0, z: 0, rotationY: Math.PI / 2 },  // Leftmost
            { x: -925, y: 0, z: 0, rotationY: Math.PI / 2 },
            { x: -555, y: 0, z: 0, rotationY: Math.PI / 2 },
            { x: -185, y: 0, z: 0, rotationY: Math.PI / 2 },
            { x: 185, y: 0, z: 0, rotationY: Math.PI / 2 },
            { x: 555, y: 0, z: 0, rotationY: Math.PI / 2 },
            { x: 925, y: 0, z: 0, rotationY: Math.PI / 2 },
            { x: 1295, y: 0, z: 0, rotationY: Math.PI / 2 }   // Rightmost
        ]
    }
];

// Load all speaker types using configuration
speakerConfigs.forEach((config, configIndex) => {
    gltfLoader.load(config.modelPath,
        (gltf) => {
            const templateModel = gltf.scene;
            
            // Get model height for stacking calculations
            const tempBox = new THREE.Box3().setFromObject(templateModel);
            const modelHeight = tempBox.max.y - tempBox.min.y;
            
            config.instances.forEach((instance, instanceIndex) => {
                const model = templateModel.clone();
                
                // Position the model
                const finalX = instance.x;
                const finalZ = instance.z;
                const rotation = instance.rotationY || 0;
                
                // Position on ground first
                positionModelOnGround(model, finalX, finalZ, rotation);
                
                // Adjust for stacking if specified
                if (instance.stackLevel && instance.stackLevel > 0) {
                    model.position.y += instance.stackLevel * modelHeight;
                }
                
                // Add metadata to the model for clicking
                (model as any).speakerConfig = config;
                (model as any).instanceIndex = instanceIndex;
                (model as any).configIndex = configIndex;
                
                console.log(`Added model: ${config.name} at position (${instance.x}, ${finalZ})`); // Debug log
                
                scene.add(model);
                clickableObjects.push(model);
            });
            
            console.log(`Added ${config.instances.length} ${config.name}(s)`);
        },
        undefined,
        function (error: any) {
            console.error(`Load Error ${config.name}:`, error);
        }
    );
});

//=============================================================================
// Animation Loop
//=============================================================================
function animate() {
    const deltaTime = clock.getDelta();

    if (!isPanning) {
        panVelocity *= Math.exp(-panDamping * deltaTime);
    }

    camera.position.x += panVelocity * deltaTime;
    
    // Update camera target position and orientation
    cameraTarget.x = camera.position.x;
    const pitchedDir = new THREE.Vector3(0, Math.sin(cameraPitchRad), -Math.cos(cameraPitchRad));
    const lookDistance = 100;
    cameraTarget.copy(camera.position).addScaledVector(pitchedDir, lookDistance);
    camera.lookAt(cameraTarget);

    // Update light position so it's centered with the camera's view
    // Place the light slightly behind the camera and above, using camera forward direction
    const backOffset = 20; // how far behind the camera the light sits
    const upOffset = 30;   // how much above the camera the light sits
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    // Calculate light position: camera position minus forward*backOffset, then up
    const lightPos = camera.position.clone().add(forward.clone().multiplyScalar(-backOffset)).add(new THREE.Vector3(0, upOffset, 0));
    spotLight.position.copy(lightPos);
    // Make the spotlight target follow where the camera is looking
    spotLight.target.position.copy(cameraTarget);
    spotLight.target.updateMatrixWorld();

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}

// Start animation after everything is set up
animate();
</script>
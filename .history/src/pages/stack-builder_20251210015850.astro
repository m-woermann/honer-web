---
// Stack Builder - Secret page for creating speaker configurations
const speakerFiles = await Astro.glob('../config/speakers/*.json');

// Create speaker config map from dynamically imported configs
const speakerConfigs: Record<string, any> = {};
speakerFiles.forEach(speakerFile => {
    const config = speakerFile.default;
    speakerConfigs[config.id] = config;
});

const availableSpeakers = Object.keys(speakerConfigs);
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stack Builder - Horner Audio</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Michroma&family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
        }
    }
    </script>
    <style>
        :root {
            --color-anthracite: #383e42;
            --color-green: #42cc5d;
            --color-dark-bg: #1a1a1a;
            --color-light-grey: #A8BAC6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: var(--color-dark-bg);
            color: white;
            overflow-x: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            height: 100vh;
        }

        .sidebar {
            background: var(--color-anthracite);
            padding: 1rem;
            overflow-y: auto;
        }

        .sidebar h2 {
            font-family: 'Michroma', sans-serif;
            color: var(--color-green);
            margin-bottom: 1rem;
            font-size: 1rem;
        }

        .speaker-list {
            margin-bottom: 2rem;
        }

        .speaker-item {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0.8rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .speaker-item:hover {
            background: rgba(66, 204, 93, 0.2);
            border-color: var(--color-green);
        }

        .speaker-item.selected {
            background: rgba(66, 204, 93, 0.3);
            border-color: var(--color-green);
        }

        .controls {
            margin-bottom: 1rem;
        }

        .control-group {
            margin-bottom: 1rem;
        }

        .control-group label {
            display: block;
            margin-bottom: 0.3rem;
            font-size: 0.9rem;
            color: var(--color-green);
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 0.5rem;
        }

        .control-group input[type="text"],
        .control-group input[type="number"],
        input[type="number"],
        input[type="text"] {
            width: 100%;
            padding: 0.5rem;
            background-color: #ffffff !important;
            border: 2px solid #666666 !important;
            color: #000000 !important;
            border-radius: 3px;
            -webkit-appearance: none !important;
            -moz-appearance: textfield !important;
            font-size: 14px !important;
            font-family: monospace !important;
        }

        .control-group input[type="number"]::-webkit-outer-spin-button,
        .control-group input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none !important;
            margin: 0 !important;
            display: none !important;
        }

        .control-group input[type="text"]:focus,
        .control-group input[type="number"]:focus,
        input[type="number"]:focus,
        input[type="text"]:focus {
            outline: none !important;
            border-color: var(--color-green) !important;
            box-shadow: 0 0 0 2px rgba(66, 204, 93, 0.2) !important;
            background-color: #ffffff !important;
            color: #000000 !important;
        }

        /* Force placeholder text color */
        .control-group input[type="text"]::placeholder,
        .control-group input[type="number"]::placeholder,
        input[type="number"]::placeholder,
        input[type="text"]::placeholder {
            color: #666666 !important;
            opacity: 1 !important;
        }

        .control-group select,
        select {
            width: 100% !important;
            padding: 0.5rem !important;
            background-color: #ffffff !important;
            border: 2px solid #666666 !important;
            color: #000000 !important;
            border-radius: 3px !important;
            font-size: 14px !important;
            -webkit-appearance: none !important;
            -moz-appearance: none !important;
            appearance: none !important;
        }

        .control-group select option,
        select option {
            background-color: #ffffff !important;
            color: #000000 !important;
            padding: 0.5rem !important;
        }

        .btn {
            background: var(--color-green);
            color: var(--color-dark-bg);
            border: none;
            padding: 0.8rem 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            width: 100%;
            margin-bottom: 0.5rem;
        }

        .btn:hover {
            background: #35a049;
        }

        .btn-danger {
            background: #cc4242;
            color: white;
        }

        .btn-danger:hover {
            background: #a03535;
        }

        .canvas-container {
            background: var(--color-dark-bg);
            border-left: 1px solid var(--color-anthracite);
            border-right: 1px solid var(--color-anthracite);
            position: relative;
            overflow: hidden;
        }

        .canvas {
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 20%, rgba(66, 204, 93, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(66, 204, 93, 0.05) 0%, transparent 50%),
                linear-gradient(180deg, var(--color-dark-bg) 0%, #0f0f0f 100%);
        }

        .speaker-visual {
            position: absolute;
            background: var(--color-green);
            border: 2px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            color: var(--color-dark-bg);
            font-weight: 600;
            text-align: center;
            transition: all 0.3s ease;
        }

        .speaker-visual:hover {
            border-color: white;
            box-shadow: 0 0 10px rgba(66, 204, 93, 0.5);
        }

        .speaker-visual.selected {
            border-color: white;
            box-shadow: 0 0 15px rgba(66, 204, 93, 0.8);
        }

        .export-area {
            background: var(--color-anthracite);
            padding: 1rem;
            overflow-y: auto;
        }

        .export-textarea {
            width: 100%;
            height: 300px;
            background: var(--color-dark-bg);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            resize: vertical;
        }

        .stack-info {
            margin-bottom: 1rem;
        }

        .stack-info input {
            width: 100%;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 3px;
            margin-bottom: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Sidebar - Speaker Library & Controls -->
        <div class="sidebar">
            <h2>Add Speakers</h2>
            <div class="speaker-list">
                {availableSpeakers.map(speakerId => (
                    <div class="speaker-item" data-speaker-id={speakerId}>
                        {speakerConfigs[speakerId].name}
                    </div>
                ))}
            </div>

            <h2>Current Speaker</h2>
            <div class="controls" id="controls">
                <p>Select a speaker to edit</p>
            </div>

            <button class="btn btn-danger" id="deleteSpeaker">Delete Selected</button>
            <button class="btn" id="clearAll">Clear All</button>
        </div>

        <!-- Center - Canvas -->
        <div class="canvas-container">
            <canvas class="canvas" id="canvas"></canvas>
        </div>

        <!-- Speaker List Panel -->
        <div id="speaker-list-panel" style="position: absolute !important; top: 20px !important; right: 330px !important; width: 300px !important; background: rgba(40, 40, 40, 0.95) !important; border: 1px solid #555 !important; border-radius: 8px !important; padding: 15px !important; color: white !important; font-family: Arial, sans-serif !important; max-height: 60vh !important; overflow-y: auto !important; z-index: 1000 !important;">
            <h3 style="margin: 0 0 15px 0 !important; color: #42cc5d !important; font-size: 16px !important;">Speakers in Scene</h3>
            <div id="speaker-list-content">
                <p style="color: #aaa !important; font-style: italic !important; margin: 0 !important;">No speakers added yet</p>
            </div>
        </div>

        <!-- Right Sidebar - Export -->
        <div class="sidebar export-area">
            <h2>Export Configuration</h2>
            <div class="stack-info">
                <input type="text" id="stackName" placeholder="Stack Name (e.g., GM Custom)" value="Custom Stack">
                <input type="text" id="stackDescription" placeholder="Description" value="Custom speaker configuration">
                <input type="number" id="stackSpacing" placeholder="Spacing" value="3000">
            </div>
            <button class="btn" id="exportStack">Generate Export</button>
            <textarea class="export-textarea" id="exportText" placeholder="Export configuration will appear here..."></textarea>
            <button class="btn" id="copyExport">Copy to Clipboard</button>
        </div>
    </div>

    <script is:inline define:vars={{speakerConfigs}} type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // Available speakers data
        console.log('Speaker configs loaded:', Object.keys(speakerConfigs).length);
        
        // Three.js variables
        let scene, camera, renderer, controls;
        let loadedModels = {};
        let speakerObjects = [];
        
        // Stack state
        let currentStack = [];
        let selectedSpeaker = null;
        let speakerCounter = 0;
        let selectedObject = null;

        // Function to update the speaker list display
        function updateSpeakerList() {
            const listContent = document.getElementById('speaker-list-content');
            
            if (currentStack.length === 0) {
                listContent.innerHTML = '<p style="color: #aaa !important; font-style: italic !important; margin: 0 !important;">No speakers added yet</p>';
                return;
            }
            
            let listHTML = '';
            currentStack.forEach((speaker, index) => {
                const isSelected = selectedSpeaker && selectedSpeaker.id === speaker.id;
                const bgColor = isSelected ? 'rgba(66, 204, 93, 0.2)' : 'rgba(60, 60, 60, 0.3)';
                
                listHTML += `
                    <div class="speaker-item" data-speaker-id="${speaker.id}" style="
                        background: ${bgColor} !important;
                        border: 1px solid ${isSelected ? '#42cc5d' : '#666'} !important;
                        border-radius: 4px !important;
                        padding: 10px !important;
                        margin-bottom: 8px !important;
                        cursor: pointer !important;
                        transition: background-color 0.2s !important;
                    ">
                        <div style="font-weight: bold !important; color: #42cc5d !important; margin-bottom: 5px !important;">
                            Speaker ${index + 1}
                        </div>
                        <div style="font-size: 12px !important; color: #ccc !important; margin-bottom: 3px !important;">
                            Model: ${speaker.model}
                        </div>
                        <div style="font-size: 11px !important; color: #aaa !important;">
                            Position: (${speaker.x}, ${speaker.y}, ${speaker.z})
                        </div>
                        <div style="font-size: 11px !important; color: #aaa !important;">
                            Rotation: (${Math.round(speaker.rotationX * 180/Math.PI)}°, ${Math.round(speaker.rotationY * 180/Math.PI)}°, ${Math.round(speaker.rotationZ * 180/Math.PI)}°)
                        </div>
                        <button onclick="removeSpeaker('${speaker.id}')" style="
                            background: #cc4242 !important;
                            color: white !important;
                            border: none !important;
                            border-radius: 3px !important;
                            padding: 4px 8px !important;
                            font-size: 10px !important;
                            cursor: pointer !important;
                            margin-top: 5px !important;
                        ">Remove</button>
                    </div>
                `;
            });
            
            listContent.innerHTML = listHTML;
            
            // Add click listeners to speaker items for selection
            document.querySelectorAll('.speaker-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (e.target.tagName !== 'BUTTON') {
                        const speakerId = item.getAttribute('data-speaker-id');
                        selectSpeakerById(speakerId);
                    }
                });
            });
        }
        
        // Function to select a speaker by ID
        function selectSpeakerById(speakerId) {
            const speaker = currentStack.find(s => s.id === speakerId);
            if (speaker) {
                selectedSpeaker = speaker;
                updatePropertiesPanel();
                updateSpeakerList();
                highlightSelectedSpeaker();
            }
        }
        
        // Function to remove a speaker
        function removeSpeaker(speakerId) {
            // Remove from scene
            const speakerObject = scene.getObjectByName(speakerId);
            if (speakerObject) {
                scene.remove(speakerObject);
            }
            
            // Remove from speakers array
            currentStack = currentStack.filter(s => s.id !== speakerId);
            
            // Clear selection if removed speaker was selected
            if (selectedSpeaker && selectedSpeaker.id === speakerId) {
                selectedSpeaker = null;
                updatePropertiesPanel();
            }
            
            updateSpeakerList();
            updateExport();
        }

        // DOM elements
        let canvas, controlsPanel, exportText;

        // Initialize after DOM is loaded
        window.addEventListener('load', function() {
            console.log('Stack Builder initialized');
            initThreeJS();
            setupEventListeners();
        });

        function initThreeJS() {
            canvas = document.getElementById('canvas');
            controlsPanel = document.getElementById('controls');
            exportText = document.getElementById('exportText');
            
            if (!canvas || !controlsPanel || !exportText) {
                console.error('Required elements not found');
                return;
            }

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Camera setup - positioned much further back to match viewer
            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 10000);
            camera.position.set(0, 500, 800);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Orbit controls - target adjusted for larger scale
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 100, 0); // Look at a point above ground level

            // Lighting - positioned for larger scene
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1000, 1000, 500);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Ground plane - much larger to accommodate full-scale models
            const groundGeometry = new THREE.PlaneGeometry(5000, 5000);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Raycaster for picking
            window.raycaster = new THREE.Raycaster();
            window.mouse = new THREE.Vector2();

            // Start render loop
            animate();

            // Preload speaker models
            preloadModels();
        }

        function preloadModels() {
            const loader = new GLTFLoader();
            
            Object.keys(speakerConfigs).forEach(speakerId => {
                const modelPath = `/${speakerId}.glb`;
                loader.load(
                    modelPath,
                    function(gltf) {
                        loadedModels[speakerId] = gltf.scene.clone();
                        console.log('Loaded model:', speakerId);
                    },
                    undefined,
                    function(error) {
                        console.error('Error loading model:', speakerId, error);
                    }
                );
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function setupEventListeners() {
            // Speaker list click handlers
            const speakerItems = document.querySelectorAll('.speaker-item');
            speakerItems.forEach(function(item) {
                item.addEventListener('click', function() {
                    const speakerId = this.getAttribute('data-speaker-id');
                    console.log('Speaker clicked:', speakerId);
                    if (speakerId) {
                        addSpeaker(speakerId);
                    }
                });
            });

            // Canvas click handler for selection
            canvas.addEventListener('click', onCanvasClick);

            // Export and control buttons
            const exportButton = document.getElementById('exportStack');
            const copyButton = document.getElementById('copyExport');
            const deleteButton = document.getElementById('deleteSpeaker');
            const clearButton = document.getElementById('clearAll');

            if (exportButton) {
                exportButton.addEventListener('click', updateExport);
            }

            if (copyButton) {
                copyButton.addEventListener('click', function() {
                    if (exportText && exportText.value) {
                        navigator.clipboard.writeText(exportText.value);
                        copyButton.textContent = 'Copied!';
                        setTimeout(() => { copyButton.textContent = 'Copy to Clipboard'; }, 1000);
                    }
                });
            }

            if (deleteButton) {
                deleteButton.addEventListener('click', function() {
                    if (selectedSpeaker) {
                        deleteSpeaker(selectedSpeaker.id);
                    }
                });
            }

            if (clearButton) {
                clearButton.addEventListener('click', function() {
                    clearAll();
                });
            }

            // Window resize handler
            window.addEventListener('resize', onWindowResize);

            console.log('All event listeners attached');
        }

        function onCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            window.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            window.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            window.raycaster.setFromCamera(window.mouse, camera);
            const intersects = window.raycaster.intersectObjects(speakerObjects, true);

            if (intersects.length > 0) {
                // Find the root speaker object
                let clickedObject = intersects[0].object;
                while (clickedObject.parent && !clickedObject.userData.speakerId) {
                    clickedObject = clickedObject.parent;
                }
                
                if (clickedObject.userData.speakerId) {
                    selectSpeaker(clickedObject.userData.speakerId);
                }
            }
        }

        function addSpeaker(speakerId) {
            console.log('Adding speaker:', speakerId);
            
            const speakerConfig = speakerConfigs[speakerId];
            if (!speakerConfig) {
                console.error('Speaker config not found:', speakerId);
                return;
            }

            if (!loadedModels[speakerId]) {
                console.error('Model not loaded for:', speakerId);
                return;
            }

            const speakerData = {
                id: 'speaker_' + speakerCounter++,
                model: speakerId,
                x: 0,
                y: speakerConfig.category === 'subwoofer' ? 0 : 800,
                z: 0,
                rotationX: 0,
                rotationY: 0,
                rotationZ: 0,
                onGround: speakerConfig.category === 'subwoofer'
            };

            currentStack.push(speakerData);
            createSpeakerObject(speakerData);
            selectSpeaker(speakerData.id);
            updateSpeakerList();
            updateExport();
            console.log('Speaker added:', speakerData);
        }

        function createSpeakerObject(speakerData) {
            const modelClone = loadedModels[speakerData.model].clone();
            
            // Use same scaling as main viewer (no additional scaling)
            // Models will be at original size like in ThreeViewer
            
            // Set position (use original values, no division needed for current scale)
            modelClone.position.set(
                speakerData.x,
                speakerData.y,
                speakerData.z
            );
            
            // Set rotation on all axes
            modelClone.rotation.set(
                speakerData.rotationX,
                speakerData.rotationY,
                speakerData.rotationZ
            );
            
            // Store reference data
            modelClone.userData.speakerId = speakerData.id;
            modelClone.userData.speakerData = speakerData;
            
            // Enable shadows and set wireframe
            modelClone.traverse(function(child) {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    
                    // Set wireframe mode
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                mat.wireframe = true;
                                mat.color.setHex(0x42cc5d); // Green wireframe
                                mat.transparent = true;
                                mat.opacity = 0.8;
                            });
                        } else {
                            child.material.wireframe = true;
                            child.material.color.setHex(0x42cc5d); // Green wireframe
                            child.material.transparent = true;
                            child.material.opacity = 0.8;
                        }
                    }
                }
            });
            
            scene.add(modelClone);
            speakerObjects.push(modelClone);
        }

        function selectSpeaker(speakerId) {
            console.log('Selecting speaker:', speakerId);
            
            // Find speaker in stack
            selectedSpeaker = null;
            selectedObject = null;
            
            for (let i = 0; i < currentStack.length; i++) {
                if (currentStack[i].id === speakerId) {
                    selectedSpeaker = currentStack[i];
                    break;
                }
            }
            
            for (let i = 0; i < speakerObjects.length; i++) {
                if (speakerObjects[i].userData.speakerId === speakerId) {
                    selectedObject = speakerObjects[i];
                    break;
                }
            }
            
            if (!selectedSpeaker || !selectedObject) {
                console.error('Speaker not found:', speakerId);
                return;
            }
            
            // Update visual selection (wireframe highlight)
            speakerObjects.forEach(obj => {
                obj.traverse(child => {
                    if (child.isMesh && child.material) {
                        const isSelected = obj === selectedObject;
                        
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                mat.color.setHex(isSelected ? 0xffff00 : 0x42cc5d); // Yellow when selected, green otherwise
                                mat.opacity = isSelected ? 1.0 : 0.8;
                            });
                        } else {
                            child.material.color.setHex(isSelected ? 0xffff00 : 0x42cc5d); // Yellow when selected, green otherwise
                            child.material.opacity = isSelected ? 1.0 : 0.8;
                        }
                    }
                });
            });
            
            renderControls();
            updateSpeakerList(); // Update the speaker list to show selection
        }

        function renderControls() {
            if (!selectedSpeaker) {
                controlsPanel.innerHTML = '<p style="color: #ccc;">Select a speaker to edit its properties</p>';
                return;
            }

            const speakerConfig = speakerConfigs[selectedSpeaker.model];
            
            controlsPanel.innerHTML = `
                <div class="control-group">
                    <label style="color: var(--color-green); font-weight: bold;">Selected: ${speakerConfig.name}</label>
                </div>
                <div class="control-group">
                    <label>X Position (mm)</label>
                    <input type="number" id="xInput" min="-5000" max="5000" value="${selectedSpeaker.x}" step="10" 
                           style="background: white !important; color: black !important; border: 2px solid #666 !important; font-size: 14px !important;">
                </div>
                <div class="control-group">
                    <label>Y Position (mm)</label>
                    <input type="number" id="yInput" min="0" max="3000" value="${selectedSpeaker.y}" step="10"
                           style="background: white !important; color: black !important; border: 2px solid #666 !important; font-size: 14px !important;">
                </div>
                <div class="control-group">
                    <label>Z Position (mm)</label>
                    <input type="number" id="zInput" min="-5000" max="5000" value="${selectedSpeaker.z}" step="10"
                           style="background: white !important; color: black !important; border: 2px solid #666 !important; font-size: 14px !important;">
                </div>
                <div class="control-group">
                    <label>X Rotation (degrees)</label>
                    <input type="number" id="rotXInput" min="0" max="359" value="${Math.round(selectedSpeaker.rotationX * 180 / Math.PI)}" step="1"
                           style="background: white !important; color: black !important; border: 2px solid #666 !important; font-size: 14px !important;">
                </div>
                <div class="control-group">
                    <label>Y Rotation (degrees)</label>
                    <input type="number" id="rotYInput" min="0" max="359" value="${Math.round(selectedSpeaker.rotationY * 180 / Math.PI)}" step="1"
                           style="background: white !important; color: black !important; border: 2px solid #666 !important; font-size: 14px !important;">
                </div>
                <div class="control-group">
                    <label>Z Rotation (degrees)</label>
                    <input type="number" id="rotZInput" min="0" max="359" value="${Math.round(selectedSpeaker.rotationZ * 180 / Math.PI)}" step="1"
                           style="background: white !important; color: black !important; border: 2px solid #666 !important; font-size: 14px !important;">
                </div>
                <div class="control-group">
                    <label>Ground Placement:</label>
                    <select id="groundSelect" style="background: white !important; color: black !important; border: 2px solid #666 !important; font-size: 14px !important; padding: 0.5rem !important;">
                        <option value="true" ${selectedSpeaker.onGround ? 'selected' : ''} style="background: white !important; color: black !important;">On Ground</option>
                        <option value="false" ${!selectedSpeaker.onGround ? 'selected' : ''} style="background: white !important; color: black !important;">Above Ground</option>
                    </select>
                </div>
            `;
            
            // Add event listeners for controls
            setupControlListeners();
        }

        function setupControlListeners() {
            const xInput = document.getElementById('xInput');
            const yInput = document.getElementById('yInput');
            const zInput = document.getElementById('zInput');
            const rotXInput = document.getElementById('rotXInput');
            const rotYInput = document.getElementById('rotYInput');
            const rotZInput = document.getElementById('rotZInput');
            const groundSelect = document.getElementById('groundSelect');

            if (xInput) {
                xInput.addEventListener('input', function() {
                    selectedSpeaker.x = parseInt(this.value) || 0;
                    selectedObject.position.x = selectedSpeaker.x;
                    updateSpeakerList();
                    updateExport();
                });
            }

            if (yInput) {
                yInput.addEventListener('input', function() {
                    selectedSpeaker.y = parseInt(this.value) || 0;
                    selectedObject.position.y = selectedSpeaker.y;
                    updateSpeakerList();
                    updateExport();
                });
            }

            if (zInput) {
                zInput.addEventListener('input', function() {
                    selectedSpeaker.z = parseInt(this.value) || 0;
                    selectedObject.position.z = selectedSpeaker.z;
                    updateSpeakerList();
                    updateExport();
                });
            }

            if (rotXInput) {
                rotXInput.addEventListener('input', function() {
                    const degrees = parseInt(this.value) || 0;
                    selectedSpeaker.rotationX = degrees * Math.PI / 180;
                    selectedObject.rotation.x = selectedSpeaker.rotationX;
                    updateSpeakerList();
                    updateExport();
                });
            }

            if (rotYInput) {
                rotYInput.addEventListener('input', function() {
                    const degrees = parseInt(this.value) || 0;
                    selectedSpeaker.rotationY = degrees * Math.PI / 180;
                    selectedObject.rotation.y = selectedSpeaker.rotationY;
                    updateSpeakerList();
                    updateExport();
                });
            }

            if (rotZInput) {
                rotZInput.addEventListener('input', function() {
                    const degrees = parseInt(this.value) || 0;
                    selectedSpeaker.rotationZ = degrees * Math.PI / 180;
                    selectedObject.rotation.z = selectedSpeaker.rotationZ;
                    updateSpeakerList();
                    updateExport();
                });
            }

            if (groundSelect) {
                groundSelect.addEventListener('change', function() {
                    selectedSpeaker.onGround = this.value === 'true';
                    updateSpeakerList();
                    updateExport();
                });
            }
        }

        function deleteSpeaker(speakerId) {
            // Remove from stack
            currentStack = currentStack.filter(speaker => speaker.id !== speakerId);
            
            // Remove from scene
            for (let i = speakerObjects.length - 1; i >= 0; i--) {
                if (speakerObjects[i].userData.speakerId === speakerId) {
                    scene.remove(speakerObjects[i]);
                    speakerObjects.splice(i, 1);
                    break;
                }
            }
            
            // Clear selection
            selectedSpeaker = null;
            selectedObject = null;
            renderControls();
            updateExport();
        }

        function clearAll() {
            // Clear all speakers
            speakerObjects.forEach(obj => scene.remove(obj));
            speakerObjects = [];
            currentStack = [];
            selectedSpeaker = null;
            selectedObject = null;
            renderControls();
            updateExport();
        }

        function updateExport() {
            const stackNameEl = document.getElementById('stackName');
            const stackDescEl = document.getElementById('stackDescription');
            const stackSpacingEl = document.getElementById('stackSpacing');
            
            const stackName = stackNameEl ? stackNameEl.value : 'Custom Stack';
            const stackDescription = stackDescEl ? stackDescEl.value : 'Custom speaker configuration';
            const stackSpacing = stackSpacingEl ? parseInt(stackSpacingEl.value) || 3000 : 3000;

            if (currentStack.length === 0) {
                exportText.value = '';
                return;
            }

            const exportData = {
                id: stackName.toLowerCase().replace(/\s+/g, '-'),
                name: stackName,
                description: stackDescription,
                spacing: stackSpacing,
                speakers: currentStack.map(speaker => ({
                    model: speaker.model,
                    x: speaker.x,
                    y: speaker.y,
                    z: speaker.z,
                    rotationX: speaker.rotationX,
                    rotationY: speaker.rotationY,
                    rotationZ: speaker.rotationZ,
                    onGround: speaker.onGround
                }))
            };

            exportText.value = JSON.stringify(exportData, null, 2);
        }

        function onWindowResize() {
            const newWidth = canvas.clientWidth;
            const newHeight = canvas.clientHeight;
            
            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
        }
    </script>
</body>
</html>
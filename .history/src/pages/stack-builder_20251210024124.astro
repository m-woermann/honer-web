---
// Stack Builder - Secret page for creating speaker configurations
const speakerFiles = await Astro.glob('../config/speakers/*.json');

// Create speaker config map from dynamically imported configs
const speakerConfigs: Record<string, any> = {};
speakerFiles.forEach(speakerFile => {
    const config = speakerFile.default;
    speakerConfigs[config.id] = config;
});

const availableSpeakers = Object.keys(speakerConfigs);
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stack Builder - Horner Audio</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Michroma&family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
        }
    }
    </script>
    <style>
        :root {
            --color-anthracite: #383e42;
            --color-green: #42cc5d;
            --color-dark-bg: #1a1a1a;
            --color-light-grey: #A8BAC6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: var(--color-dark-bg);
            color: white;
            overflow-x: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            height: 100vh;
        }

        .sidebar {
            background: var(--color-anthracite);
            padding: 1rem;
            overflow-y: auto;
        }

        .sidebar h2 {
            font-family: 'Michroma', sans-serif;
            color: var(--color-green);
            margin-bottom: 1rem;
            font-size: 1rem;
        }

        .speaker-list {
            margin-bottom: 2rem;
        }

        .speaker-item {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0.8rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .speaker-item:hover {
            background: rgba(66, 204, 93, 0.2);
            border-color: var(--color-green);
        }

        .speaker-item.selected {
            background: rgba(66, 204, 93, 0.3);
            border-color: var(--color-green);
        }

        .controls {
            margin-bottom: 1rem;
        }

        .control-group {
            margin-bottom: 1rem;
        }

        .control-group label {
            display: block;
            margin-bottom: 0.3rem;
            font-size: 0.9rem;
            color: var(--color-green);
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 0.5rem;
        }

        .control-group input[type="text"],
        .control-group input[type="number"],
        input[type="number"],
        input[type="text"] {
            width: 100%;
            padding: 0.5rem;
            background-color: #ffffff !important;
            border: 2px solid #666666 !important;
            color: #000000 !important;
            border-radius: 3px;
            -webkit-appearance: none !important;
            -moz-appearance: textfield !important;
            font-size: 14px !important;
            font-family: monospace !important;
        }

        .control-group input[type="number"]::-webkit-outer-spin-button,
        .control-group input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none !important;
            margin: 0 !important;
            display: none !important;
        }

        .control-group input[type="text"]:focus,
        .control-group input[type="number"]:focus,
        input[type="number"]:focus,
        input[type="text"]:focus {
            outline: none !important;
            border-color: var(--color-green) !important;
            box-shadow: 0 0 0 2px rgba(66, 204, 93, 0.2) !important;
            background-color: #ffffff !important;
            color: #000000 !important;
        }

        /* Force placeholder text color */
        .control-group input[type="text"]::placeholder,
        .control-group input[type="number"]::placeholder,
        input[type="number"]::placeholder,
        input[type="text"]::placeholder {
            color: #666666 !important;
            opacity: 1 !important;
        }

        .control-group select,
        select {
            width: 100% !important;
            padding: 0.5rem !important;
            background-color: #ffffff !important;
            border: 2px solid #666666 !important;
            color: #000000 !important;
            border-radius: 3px !important;
            font-size: 14px !important;
            -webkit-appearance: none !important;
            -moz-appearance: none !important;
            appearance: none !important;
        }

        .control-group select option,
        select option {
            background-color: #ffffff !important;
            color: #000000 !important;
            padding: 0.5rem !important;
        }

        .btn {
            background: var(--color-green);
            color: var(--color-dark-bg);
            border: none;
            padding: 0.8rem 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            width: 100%;
            margin-bottom: 0.5rem;
        }

        .btn:hover {
            background: #35a049;
        }

        .btn-danger {
            background: #cc4242;
            color: white;
        }

        .btn-danger:hover {
            background: #a03535;
        }

        #symmetryButton {
            background: #cc8842 !important;
            color: white !important;
        }

        #symmetryButton:hover {
            background: #a66d33 !important;
        }

        .canvas-container {
            background: var(--color-dark-bg);
            border-left: 1px solid var(--color-anthracite);
            border-right: 1px solid var(--color-anthracite);
            position: relative;
            overflow: hidden;
        }

        .canvas {
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 20%, rgba(66, 204, 93, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(66, 204, 93, 0.05) 0%, transparent 50%),
                linear-gradient(180deg, var(--color-dark-bg) 0%, #0f0f0f 100%);
        }

        .speaker-visual {
            position: absolute;
            background: var(--color-green);
            border: 2px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            color: var(--color-dark-bg);
            font-weight: 600;
            text-align: center;
            transition: all 0.3s ease;
        }

        .speaker-visual:hover {
            border-color: white;
            box-shadow: 0 0 10px rgba(66, 204, 93, 0.5);
        }

        .speaker-visual.selected {
            border-color: white;
            box-shadow: 0 0 15px rgba(66, 204, 93, 0.8);
        }

        .export-area {
            background: var(--color-anthracite);
            padding: 1rem;
            overflow-y: auto;
        }

        .export-textarea {
            width: 100%;
            height: 300px;
            background: var(--color-dark-bg);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            resize: vertical;
        }

        .stack-info {
            margin-bottom: 1rem;
        }

        .stack-info input {
            width: 100%;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 3px;
            margin-bottom: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Sidebar - Speaker Library & Controls -->
        <div class="sidebar">
            <h2>Add Speakers</h2>
            
            <!-- Auto-Symmetry Toggle -->
            <div class="control-group" style="background: rgba(60, 60, 60, 0.5) !important; padding: 15px !important; border-radius: 6px !important; margin-bottom: 15px !important; border: 1px solid #666 !important;">
                <label style="color: white !important; font-weight: bold !important; margin-bottom: 10px !important; display: block !important; cursor: pointer !important;">
                    <input type="checkbox" id="autoSymmetry" style="margin-right: 8px !important; transform: scale(1.2) !important;">
                    ðŸªž Auto-Create Symmetric Pairs
                </label>
                <p style="color: #aaa !important; font-size: 12px !important; margin: 0 !important; line-height: 1.4 !important;">
                    When enabled, adding a speaker creates both left and right speakers automatically
                </p>
            </div>
            
            <div class="speaker-list">
                {availableSpeakers.map(speakerId => (
                    <div class="speaker-item" data-speaker-id={speakerId}>
                        {speakerConfigs[speakerId].name}
                    </div>
                ))}
            </div>

            <h2>Current Speaker</h2>
            <div class="controls" id="controls">
                <p>Select a speaker to edit</p>
            </div>

            <button class="btn btn-danger" id="deleteSpeaker">Delete Selected</button>
            <button class="btn" id="clearAll">Clear All</button>
        </div>

        <!-- Center - Canvas -->
        <div class="canvas-container">
            <canvas class="canvas" id="canvas"></canvas>
        </div>

        <!-- Speaker List Panel -->
        <div id="speaker-list-panel" style="position: absolute !important; top: 20px !important; right: 330px !important; width: 200px !important; background: rgba(40, 40, 40, 0.95) !important; border: 1px solid #555 !important; border-radius: 8px !important; padding: 10px !important; color: white !important; font-family: Arial, sans-serif !important; max-height: 300px !important; overflow-y: auto !important; z-index: 1000 !important; font-size: 12px !important;">
            <h3 style="margin: 0 0 10px 0 !important; color: #42cc5d !important; font-size: 14px !important;">Speakers</h3>
            <div id="speaker-list-content">
                <p style="color: #aaa !important; font-style: italic !important; margin: 0 !important;">No speakers added yet</p>
            </div>
        </div>

        <!-- Right Sidebar - Export -->
        <div class="sidebar export-area">
            <h2>Export Configuration</h2>
            <div class="stack-info">
                <input type="text" id="stackName" placeholder="Stack Name (e.g., GM Custom)" value="Custom Stack">
                <input type="text" id="stackDescription" placeholder="Description" value="Custom speaker configuration">
                <input type="number" id="stackSpacing" placeholder="Spacing" value="3000">
            </div>
            <button class="btn" id="exportStack">Generate Export</button>
            <button class="btn" id="symmetryButton" style="background: #cc8842 !important;">Mirror Symmetry</button>
            <button class="btn" id="debugButton" style="background: #4287cc !important;">Debug Pairs</button>
            <textarea class="export-textarea" id="exportText" placeholder="Export configuration will appear here..."></textarea>
            <button class="btn" id="copyExport">Copy to Clipboard</button>
        </div>
    </div>

    <script is:inline define:vars={{speakerConfigs}} type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // Available speakers data
        console.log('Speaker configs loaded:', Object.keys(speakerConfigs).length);
        
        // Three.js variables
        let scene, camera, renderer, controls;
        let loadedModels = {};
        let speakerObjects = [];
        
        // Stack state
        let currentStack = [];
        let selectedSpeaker = null;
        let speakerCounter = 0;
        let selectedObject = null;

        // Function to update the speaker list display
        function updateSpeakerList() {
            const listContent = document.getElementById('speaker-list-content');
            if (currentStack.length === 0) {
                listContent.innerHTML = '<p style="color: #aaa !important; font-style: italic !important; margin: 0 !important;">No speakers added yet</p>';
                return;
            }
            
            let listHTML = '';
            let processedSpeakers = new Set();
            let speakerIndex = 1;
            
            currentStack.forEach((speaker) => {
                // Skip if this speaker was already processed as part of a pair
                if (processedSpeakers.has(speaker.id)) return;
                
                const isSelected = selectedSpeaker && (
                    selectedSpeaker.id === speaker.id || 
                    (speaker.pairId && selectedSpeaker.pairId === speaker.pairId)
                );
                
                if (speaker.pairId) {
                    // This is a paired speaker - find its partner
                    const partner = currentStack.find(s => s.pairId === speaker.pairId && s.id !== speaker.id);
                    if (partner) {
                        processedSpeakers.add(speaker.id);
                        processedSpeakers.add(partner.id);
                        
                        const leftSpeaker = speaker.isLeftSpeaker ? speaker : partner;
                        const rightSpeaker = speaker.isLeftSpeaker ? partner : speaker;
                        
                        const bgColor = isSelected ? 'rgba(66, 204, 93, 0.2)' : 'rgba(60, 60, 60, 0.3)';
                        
                        listHTML += `
                            <div class="speaker-pair-item" data-pair-id="${speaker.pairId}" style="
                                background: ${bgColor} !important;
                                border: 1px solid ${isSelected ? '#42cc5d' : '#666'} !important;
                                border-radius: 3px !important;
                                padding: 6px !important;
                                margin-bottom: 4px !important;
                                cursor: pointer !important;
                                transition: background-color 0.2s !important;
                                font-size: 11px !important;
                                border-left: 3px solid #ffa500 !important;
                            ">
                                <div style="font-weight: bold !important; color: #42cc5d !important; margin-bottom: 2px !important; font-size: 11px !important; display: flex !important; justify-content: space-between !important; align-items: center !important;">
                                    <span>ðŸ”— SP${speakerIndex} Pair</span>
                                    <button onclick="removeSpeakerPair('${speaker.pairId}')" style="
                                        background: #cc4242 !important;
                                        color: white !important;
                                        border: none !important;
                                        border-radius: 2px !important;
                                        padding: 2px 6px !important;
                                        font-size: 9px !important;
                                        cursor: pointer !important;
                                    ">Ã—</button>
                                </div>
                                <div style="font-size: 10px !important; color: #aaa !important; margin-bottom: 2px !important;">
                                    ${speaker.model.replace('gm-', '').replace('-', ' ')} (Linked)
                                </div>
                                <div style="font-size: 9px !important; color: #888 !important; line-height: 1.2 !important;">
                                    L: (${leftSpeaker.x}, ${leftSpeaker.y}, ${leftSpeaker.z})<br>
                                    R: (${rightSpeaker.x}, ${rightSpeaker.y}, ${rightSpeaker.z})
                                </div>
                            </div>
                        `;
                    }
                } else {
                    // Single speaker (not paired)
                    processedSpeakers.add(speaker.id);
                    const bgColor = isSelected ? 'rgba(66, 204, 93, 0.2)' : 'rgba(60, 60, 60, 0.3)';
                    
                    listHTML += `
                        <div class="speaker-item" data-speaker-id="${speaker.id}" style="
                            background: ${bgColor} !important;
                            border: 1px solid ${isSelected ? '#42cc5d' : '#666'} !important;
                            border-radius: 3px !important;
                            padding: 6px !important;
                            margin-bottom: 4px !important;
                            cursor: pointer !important;
                            transition: background-color 0.2s !important;
                            font-size: 11px !important;
                        ">
                            <div style="font-weight: bold !important; color: #42cc5d !important; margin-bottom: 2px !important; font-size: 11px !important; display: flex !important; justify-content: space-between !important; align-items: center !important;">
                                <span>SP${speakerIndex}</span>
                                <button onclick="removeSpeaker('${speaker.id}')" style="
                                    background: #cc4242 !important;
                                    color: white !important;
                                    border: none !important;
                                    border-radius: 2px !important;
                                    padding: 2px 6px !important;
                                    font-size: 9px !important;
                                    cursor: pointer !important;
                                ">Ã—</button>
                            </div>
                            <div style="font-size: 10px !important; color: #aaa !important;">
                                ${speaker.model.replace('gm-', '').replace('-', ' ')}
                            </div>
                            <div style="font-size: 9px !important; color: #888 !important;">
                                (${speaker.x}, ${speaker.y}, ${speaker.z})
                            </div>
                        </div>
                    `;
                }
                speakerIndex++;
            });
            
            listContent.innerHTML = listHTML;
            
            // Add click listeners to speaker items for selection
            document.querySelectorAll('.speaker-item').forEach(item => {
                console.log('Adding click listener to:', item.getAttribute('data-speaker-id'));
                item.addEventListener('click', (e) => {
                    console.log('Speaker item clicked!', e.target, e.currentTarget);
                    // If the click was on the remove button, don't select
                    if (e.target.tagName === 'BUTTON' || e.target.textContent === 'Ã—') {
                        console.log('Button clicked, not selecting speaker');
                        return;
                    }
                    const speakerId = item.getAttribute('data-speaker-id');
                    console.log('Selecting speaker:', speakerId);
                    selectSpeakerById(speakerId);
                });
            });
            
            // Add click listeners to paired speaker items
            document.querySelectorAll('.speaker-pair-item').forEach(item => {
                console.log('Adding pair click listener to:', item.getAttribute('data-pair-id'));
                item.addEventListener('click', (e) => {
                    console.log('Speaker pair clicked!', e.target, e.currentTarget);
                    // If the click was on the remove button, don't select
                    if (e.target.tagName === 'BUTTON' || e.target.textContent === 'Ã—') {
                        console.log('Button clicked, not selecting pair');
                        return;
                    }
                    const pairId = item.getAttribute('data-pair-id');
                    console.log('Selecting speaker pair:', pairId);
                    selectSpeakerPairById(pairId);
                });
            });
        }
        
        // Function to select a speaker by ID
        function selectSpeakerById(speakerId) {
            console.log('selectSpeakerById called with:', speakerId);
            const speaker = currentStack.find(s => s.id === speakerId);
            console.log('Found speaker:', speaker);
            if (speaker) {
                selectedSpeaker = speaker;
                console.log('Selected speaker set to:', selectedSpeaker);
                // updatePropertiesPanel(); // TODO: Implement this function
                updateSpeakerList();
                highlightSelectedSpeaker();
            } else {
                console.log('Speaker not found in currentStack:', currentStack);
            }
        }
        
        // Function to remove a speaker
        function removeSpeaker(speakerId) {
            // Remove from scene
            const speakerObject = scene.getObjectByName(speakerId);
            if (speakerObject) {
                scene.remove(speakerObject);
            }
            
            // Remove from speakerObjects array
            speakerObjects = speakerObjects.filter(obj => obj.userData.speakerId !== speakerId);
            
            // Remove from speakers array
            currentStack = currentStack.filter(s => s.id !== speakerId);
            
            // Clear selection if removed speaker was selected
            if (selectedSpeaker && selectedSpeaker.id === speakerId) {
                selectedSpeaker = null;
                selectedObject = null;
                renderControls(); // Update the controls panel
            }
            
            updateSpeakerList();
            updateExport();
        }

        // Function to highlight the selected speaker in the 3D scene
        function highlightSelectedSpeaker() {
            speakerObjects.forEach(obj => {
                obj.traverse(child => {
                    if (child.isMesh && child.material) {
                        const isSelected = selectedSpeaker && obj.userData.speakerId === selectedSpeaker.id;
                        const targetColor = isSelected ? 0xffff00 : 0x42cc5d; // Yellow when selected, green otherwise
                        const targetOpacity = isSelected ? 1.0 : 0.8;
                        
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                if (mat.color) {
                                    mat.color.setHex(targetColor);
                                    mat.opacity = targetOpacity;
                                    mat.needsUpdate = true;
                                }
                            });
                        } else if (child.material.color) {
                            child.material.color.setHex(targetColor);
                            child.material.opacity = targetOpacity;
                            child.material.needsUpdate = true;
                        }
                    }
                });
            });
            
            // Force a render to show color changes immediately
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // Function to update paired speaker when one speaker changes
        function updatePairedSpeaker(changedSpeaker, property, value) {
            if (!changedSpeaker.pairId) {
                console.log('No pair ID found for speaker:', changedSpeaker.id);
                return; // Not part of a pair
            }
            
            // Find the paired speaker
            const pairedSpeaker = currentStack.find(speaker => 
                speaker.pairId === changedSpeaker.pairId && speaker.id !== changedSpeaker.id
            );
            
            if (!pairedSpeaker) {
                console.log('No paired speaker found for pair ID:', changedSpeaker.pairId);
                return; // No pair found
            }
            
            // Find the paired object in the scene
            const pairedObject = speakerObjects.find(obj => obj.userData.speakerId === pairedSpeaker.id);
            if (!pairedObject) {
                console.error('No paired object found in scene for speaker:', pairedSpeaker.id);
                console.log('Available speaker objects:', speakerObjects.map(obj => ({
                    id: obj.userData.speakerId,
                    name: obj.name,
                    position: obj.position
                })));
                return;
            }
            
            console.log('Found paired object:', pairedObject.userData.speakerId, 'at position:', pairedObject.position);
            console.log('Updating paired speaker:', pairedSpeaker.id, 'property:', property, 'value:', value);
            
            // Update the paired speaker based on the property
            switch (property) {
                case 'x':
                    // Mirror X position - if one is at -1000, other should be at +1000
                    const mirroredX = -value; // Simple negation for symmetric mirroring
                    pairedSpeaker.x = mirroredX;
                    pairedObject.position.x = mirroredX;
                    console.log('Mirrored X position:', value, '->', mirroredX);
                    break;
                    
                case 'y':
                    // Same Y position
                    pairedSpeaker.y = value;
                    pairedObject.position.y = value;
                    console.log('Synchronized Y position:', value);
                    break;
                    
                case 'z':
                    // Same Z position
                    pairedSpeaker.z = value;
                    pairedObject.position.z = value;
                    console.log('Synchronized Z position:', value);
                    break;
                    
                case 'rotationX':
                    // Same X rotation
                    pairedSpeaker.rotationX = value;
                    pairedObject.rotation.x = value;
                    console.log('Synchronized X rotation:', value);
                    break;
                    
                case 'rotationY':
                    // Mirror Y rotation (facing direction)
                    const mirroredRotY = -value;
                    pairedSpeaker.rotationY = mirroredRotY;
                    pairedObject.rotation.y = mirroredRotY;
                    console.log('Mirrored Y rotation:', value, '->', mirroredRotY);
                    break;
                    
                case 'rotationZ':
                    // Same Z rotation
                    pairedSpeaker.rotationZ = value;
                    pairedObject.rotation.z = value;
                    console.log('Synchronized Z rotation:', value);
                    break;
                    
                case 'onGround':
                    // Same ground setting
                    pairedSpeaker.onGround = value;
                    console.log('Synchronized ground setting:', value);
                    break;
                    
                default:
                    console.log('Unknown property for pairing:', property);
            }
            
            // Force a render update to show the changes
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
                console.log('Forced scene render after pair update');
            }
        }

        // Function to create symmetric speakers
        function createSymmetry() {
            if (currentStack.length === 0) {
                alert('Add some speakers first before creating symmetry!');
                return;
            }

            // Get confirmation from user
            if (!confirm('This will mirror all current speakers across the center axis. Continue?')) {
                return;
            }

            // Find the center X position of all speakers
            const xPositions = currentStack.map(speaker => speaker.x);
            const minX = Math.min(...xPositions);
            const maxX = Math.max(...xPositions);
            const centerX = (minX + maxX) / 2;

            // Create mirrored speakers
            const speakersToMirror = [...currentStack]; // Copy the current stack
            
            speakersToMirror.forEach(originalSpeaker => {
                // Calculate mirrored X position
                const distanceFromCenter = originalSpeaker.x - centerX;
                const mirroredX = centerX - distanceFromCenter;
                
                // Skip if the mirrored position would be the same as original (already on center line)
                if (Math.abs(mirroredX - originalSpeaker.x) < 50) {
                    return;
                }
                
                // Check if a speaker already exists at the mirrored position
                const existingAtMirrorPos = currentStack.find(speaker => 
                    Math.abs(speaker.x - mirroredX) < 100 && // Within 100 units
                    Math.abs(speaker.y - originalSpeaker.y) < 100 && 
                    Math.abs(speaker.z - originalSpeaker.z) < 100
                );
                
                if (existingAtMirrorPos) {
                    return; // Skip if speaker already exists at mirrored position
                }

                // Create mirrored speaker data
                speakerCounter++;
                const mirroredSpeaker = {
                    id: `speaker-${speakerCounter}`,
                    model: originalSpeaker.model,
                    x: mirroredX,
                    y: originalSpeaker.y,
                    z: originalSpeaker.z,
                    rotationX: originalSpeaker.rotationX,
                    rotationY: -originalSpeaker.rotationY, // Mirror Y rotation for facing direction
                    rotationZ: originalSpeaker.rotationZ,
                    onGround: originalSpeaker.onGround
                };

                // Add the mirrored speaker
                currentStack.push(mirroredSpeaker);
                createSpeakerObject(mirroredSpeaker);
            });

            // Update displays
            updateSpeakerList();
            updateExport();
            
            console.log(`Created ${speakersToMirror.length} mirrored speakers`);
        }

        // Debug function to inspect current pairs
        function debugPairs() {
            console.log('=== PAIR DEBUG INFO ===');
            console.log('Current Stack:', currentStack);
            console.log('Speaker Objects:', speakerObjects);
            
            // Group speakers by pair ID
            const pairs = {};
            const unpaired = [];
            
            currentStack.forEach(speaker => {
                if (speaker.pairId) {
                    if (!pairs[speaker.pairId]) {
                        pairs[speaker.pairId] = [];
                    }
                    pairs[speaker.pairId].push(speaker);
                } else {
                    unpaired.push(speaker);
                }
            });
            
            console.log('Paired speakers:', pairs);
            console.log('Unpaired speakers:', unpaired);
            console.log('Selected speaker:', selectedSpeaker);
            
            if (selectedSpeaker && selectedSpeaker.pairId) {
                console.log('Selected speaker pair ID:', selectedSpeaker.pairId);
                const pairedSpeaker = currentStack.find(s => 
                    s.pairId === selectedSpeaker.pairId && s.id !== selectedSpeaker.id
                );
                console.log('Found paired speaker:', pairedSpeaker);
            }
            
            alert('Debug info logged to console - check F12 Developer Tools');
        }

        // DOM elements
        let canvas, controlsPanel, exportText;

        // Initialize after DOM is loaded
        window.addEventListener('load', function() {
            console.log('Stack Builder initialized');
            initThreeJS();
            setupEventListeners();
        });

        function initThreeJS() {
            canvas = document.getElementById('canvas');
            controlsPanel = document.getElementById('controls');
            exportText = document.getElementById('exportText');
            
            if (!canvas || !controlsPanel || !exportText) {
                console.error('Required elements not found');
                return;
            }

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Camera setup - positioned much further back to match viewer
            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 10000);
            camera.position.set(0, 500, 800);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Orbit controls - target adjusted for larger scale
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 100, 0); // Look at a point above ground level

            // Lighting - positioned for larger scene
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1000, 1000, 500);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Ground plane - much larger to accommodate full-scale models
            const groundGeometry = new THREE.PlaneGeometry(5000, 5000);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Raycaster for picking - DISABLED (use speaker list only)
            // window.raycaster = new THREE.Raycaster();
            // window.mouse = new THREE.Vector2();

            // Start render loop
            animate();

            // Preload speaker models
            preloadModels();
        }

        function preloadModels() {
            const loader = new GLTFLoader();
            
            Object.keys(speakerConfigs).forEach(speakerId => {
                const modelPath = `/${speakerId}.glb`;
                loader.load(
                    modelPath,
                    function(gltf) {
                        loadedModels[speakerId] = gltf.scene.clone();
                        console.log('Loaded model:', speakerId);
                    },
                    undefined,
                    function(error) {
                        console.error('Error loading model:', speakerId, error);
                    }
                );
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function setupEventListeners() {
            // Speaker list click handlers for left sidebar (add speakers)
            const leftSidebarSpeakerItems = document.querySelectorAll('.speaker-list .speaker-item');
            leftSidebarSpeakerItems.forEach(function(item) {
                item.addEventListener('click', function() {
                    const speakerId = this.getAttribute('data-speaker-id');
                    console.log('Adding speaker from left sidebar:', speakerId);
                    if (speakerId) {
                        addSpeaker(speakerId);
                    }
                });
            });

            // Canvas click handler for selection - DISABLED (use speaker list only)
            // canvas.addEventListener('click', onCanvasClick);

            // Export and control buttons
            const exportButton = document.getElementById('exportStack');
            const copyButton = document.getElementById('copyExport');
            const symmetryButton = document.getElementById('symmetryButton');
            const debugButton = document.getElementById('debugButton');
            const deleteButton = document.getElementById('deleteSpeaker');
            const clearButton = document.getElementById('clearAll');

            if (exportButton) {
                exportButton.addEventListener('click', updateExport);
            }

            if (symmetryButton) {
                symmetryButton.addEventListener('click', createSymmetry);
            }

            if (debugButton) {
                debugButton.addEventListener('click', debugPairs);
            }

            // Auto-symmetry toggle event listener
            const autoSymmetryToggle = document.getElementById('autoSymmetry');
            if (autoSymmetryToggle) {
                autoSymmetryToggle.addEventListener('change', function() {
                    const isEnabled = this.checked;
                    const speakerButtons = document.querySelectorAll('.speaker-item');
                    
                    speakerButtons.forEach(button => {
                        if (isEnabled) {
                            button.style.background = 'linear-gradient(45deg, #42cc5d, #369c4a) !important';
                            button.style.boxShadow = '0 0 10px rgba(66, 204, 93, 0.3) !important';
                        } else {
                            button.style.background = '';
                            button.style.boxShadow = '';
                        }
                    });
                    
                    console.log('Auto-symmetry mode:', isEnabled ? 'enabled' : 'disabled');
                });
            }

            if (copyButton) {
                copyButton.addEventListener('click', function() {
                    if (exportText && exportText.value) {
                        navigator.clipboard.writeText(exportText.value);
                        copyButton.textContent = 'Copied!';
                        setTimeout(() => { copyButton.textContent = 'Copy to Clipboard'; }, 1000);
                    }
                });
            }

            if (deleteButton) {
                deleteButton.addEventListener('click', function() {
                    if (selectedSpeaker) {
                        deleteSpeaker(selectedSpeaker.id);
                    }
                });
            }

            if (clearButton) {
                clearButton.addEventListener('click', function() {
                    clearAll();
                });
            }

            // Window resize handler
            window.addEventListener('resize', onWindowResize);

            console.log('All event listeners attached');
        }

        // Canvas click function - DISABLED (use speaker list only)
        // function onCanvasClick(event) {
        //     const rect = canvas.getBoundingClientRect();
        //     window.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        //     window.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        //     window.raycaster.setFromCamera(window.mouse, camera);
        //     const intersects = window.raycaster.intersectObjects(speakerObjects, true);

        //     if (intersects.length > 0) {
        //         // Find the root speaker object
        //         let clickedObject = intersects[0].object;
        //         while (clickedObject.parent && !clickedObject.userData.speakerId) {
        //             clickedObject = clickedObject.parent;
        //         }
                
        //         if (clickedObject.userData.speakerId) {
        //             selectSpeaker(clickedObject.userData.speakerId);
        //         }
        //     }
        // }

        function addSpeaker(speakerId) {
            console.log('Adding speaker:', speakerId);
            
            const speakerConfig = speakerConfigs[speakerId];
            if (!speakerConfig) {
                console.error('Speaker config not found:', speakerId);
                return;
            }

            if (!loadedModels[speakerId]) {
                console.error('Model not loaded for:', speakerId);
                return;
            }

            const autoSymmetry = document.getElementById('autoSymmetry')?.checked || false;
            
            if (autoSymmetry) {
                // Create symmetric pair with linking
                const pairId = `pair_${Date.now()}`; // Unique pair identifier
                
                const leftSpeakerData = {
                    id: 'speaker_' + speakerCounter++,
                    model: speakerId,
                    x: -1000, // Left side
                    y: speakerConfig.category === 'subwoofer' ? 0 : 800,
                    z: 0,
                    rotationX: 0,
                    rotationY: 0,
                    rotationZ: 0,
                    onGround: speakerConfig.category === 'subwoofer',
                    pairId: pairId,
                    isLeftSpeaker: true
                };

                const rightSpeakerData = {
                    id: 'speaker_' + speakerCounter++,
                    model: speakerId,
                    x: 1000, // Right side
                    y: speakerConfig.category === 'subwoofer' ? 0 : 800,
                    z: 0,
                    rotationX: 0,
                    rotationY: 0,
                    rotationZ: 0,
                    onGround: speakerConfig.category === 'subwoofer',
                    pairId: pairId,
                    isLeftSpeaker: false
                };

                // Add both speakers
                currentStack.push(leftSpeakerData);
                currentStack.push(rightSpeakerData);
                createSpeakerObject(leftSpeakerData);
                createSpeakerObject(rightSpeakerData);
                selectSpeaker(rightSpeakerData.id); // Select the right speaker by default
                
                console.log('Linked symmetric pair created with pairId:', pairId);
                console.log('Left speaker:', leftSpeakerData);
                console.log('Right speaker:', rightSpeakerData);
            } else {
                // Create single speaker (original behavior)
                const speakerData = {
                    id: 'speaker_' + speakerCounter++,
                    model: speakerId,
                    x: 0,
                    y: speakerConfig.category === 'subwoofer' ? 0 : 800,
                    z: 0,
                    rotationX: 0,
                    rotationY: 0,
                    rotationZ: 0,
                    onGround: speakerConfig.category === 'subwoofer'
                };

                currentStack.push(speakerData);
                createSpeakerObject(speakerData);
                selectSpeaker(speakerData.id);
                
                console.log('Single speaker added:', speakerData);
            }
            
            updateSpeakerList();
            updateExport();
        }

        function createSpeakerObject(speakerData) {
            const modelClone = loadedModels[speakerData.model].clone();
            
            // Use same scaling as main viewer (no additional scaling)
            // Models will be at original size like in ThreeViewer
            
            // Set position (use original values, no division needed for current scale)
            modelClone.position.set(
                speakerData.x,
                speakerData.y,
                speakerData.z
            );
            
            // Set rotation on all axes
            modelClone.rotation.set(
                speakerData.rotationX,
                speakerData.rotationY,
                speakerData.rotationZ
            );
            
            // Store reference data
            modelClone.userData.speakerId = speakerData.id;
            modelClone.userData.speakerData = speakerData;
            modelClone.name = speakerData.id; // Set name for easy lookup
            
            // Enable shadows and set wireframe
            modelClone.traverse(function(child) {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    
                    // Set wireframe mode
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                mat.wireframe = true;
                                mat.color.setHex(0x42cc5d); // Green wireframe
                                mat.transparent = true;
                                mat.opacity = 0.8;
                            });
                        } else {
                            child.material.wireframe = true;
                            child.material.color.setHex(0x42cc5d); // Green wireframe
                            child.material.transparent = true;
                            child.material.opacity = 0.8;
                        }
                    }
                }
            });
            
            scene.add(modelClone);
            speakerObjects.push(modelClone);
        }

        function selectSpeaker(speakerId) {
            console.log('Selecting speaker:', speakerId);
            
            // Find speaker in stack
            selectedSpeaker = null;
            selectedObject = null;
            
            for (let i = 0; i < currentStack.length; i++) {
                if (currentStack[i].id === speakerId) {
                    selectedSpeaker = currentStack[i];
                    break;
                }
            }
            
            for (let i = 0; i < speakerObjects.length; i++) {
                if (speakerObjects[i].userData.speakerId === speakerId) {
                    selectedObject = speakerObjects[i];
                    break;
                }
            }
            
            if (!selectedSpeaker || !selectedObject) {
                console.error('Speaker not found:', speakerId);
                return;
            }
            
            // Update visual selection (wireframe highlight)
            highlightSelectedSpeaker();
            
            renderControls();
            updateSpeakerList(); // Update the speaker list to show selection
        }

        function renderControls() {
            if (!selectedSpeaker) {
                controlsPanel.innerHTML = '<p style="color: #ccc;">Select a speaker to edit its properties</p>';
                return;
            }

            const speakerConfig = speakerConfigs[selectedSpeaker.model];
            const isPaired = selectedSpeaker.pairId ? true : false;
            const pairIndicator = isPaired ? `<span style="color: #ffa500; margin-left: 10px;">ðŸ”— ${selectedSpeaker.isLeftSpeaker ? 'Left' : 'Right'} (Linked)</span>` : '';
            
            controlsPanel.innerHTML = `
                <div class="control-group">
                    <label style="color: var(--color-green); font-weight: bold;">Selected: ${speakerConfig.name}${pairIndicator}</label>
                    ${isPaired ? '<p style="color: #ffa500; font-size: 12px; margin: 5px 0; font-style: italic;">Changes will affect both linked speakers</p>' : ''}
                    ${isPaired ? '<button id="unlinkBtn" style="background: #cc4242 !important; color: white !important; border: none !important; padding: 5px 10px !important; border-radius: 3px !important; margin: 5px 0 !important; font-size: 12px !important; cursor: pointer !important;">ðŸ”“ Unlink Pair</button>' : ''}
                </div>
                <div class="control-group">
                    <label>X Position (mm)</label>
                    <input type="number" id="xInput" min="-5000" max="5000" value="${selectedSpeaker.x}" step="10" 
                           style="background: white !important; color: black !important; border: 2px solid #666 !important; font-size: 14px !important;">
                </div>
                <div class="control-group">
                    <label>Y Position (mm)</label>
                    <input type="number" id="yInput" min="0" max="3000" value="${selectedSpeaker.y}" step="10"
                           style="background: white !important; color: black !important; border: 2px solid #666 !important; font-size: 14px !important;">
                </div>
                <div class="control-group">
                    <label>Z Position (mm)</label>
                    <input type="number" id="zInput" min="-5000" max="5000" value="${selectedSpeaker.z}" step="10"
                           style="background: white !important; color: black !important; border: 2px solid #666 !important; font-size: 14px !important;">
                </div>
                <div class="control-group">
                    <label>X Rotation (degrees)</label>
                    <input type="number" id="rotXInput" min="0" max="359" value="${Math.round(selectedSpeaker.rotationX * 180 / Math.PI)}" step="1"
                           style="background: white !important; color: black !important; border: 2px solid #666 !important; font-size: 14px !important;">
                </div>
                <div class="control-group">
                    <label>Y Rotation (degrees)</label>
                    <input type="number" id="rotYInput" min="0" max="359" value="${Math.round(selectedSpeaker.rotationY * 180 / Math.PI)}" step="1"
                           style="background: white !important; color: black !important; border: 2px solid #666 !important; font-size: 14px !important;">
                </div>
                <div class="control-group">
                    <label>Z Rotation (degrees)</label>
                    <input type="number" id="rotZInput" min="0" max="359" value="${Math.round(selectedSpeaker.rotationZ * 180 / Math.PI)}" step="1"
                           style="background: white !important; color: black !important; border: 2px solid #666 !important; font-size: 14px !important;">
                </div>
                <div class="control-group">
                    <label>Ground Placement:</label>
                    <select id="groundSelect" style="background: white !important; color: black !important; border: 2px solid #666 !important; font-size: 14px !important; padding: 0.5rem !important;">
                        <option value="true" ${selectedSpeaker.onGround ? 'selected' : ''} style="background: white !important; color: black !important;">On Ground</option>
                        <option value="false" ${!selectedSpeaker.onGround ? 'selected' : ''} style="background: white !important; color: black !important;">Above Ground</option>
                    </select>
                </div>
            `;
            
            // Add event listeners for controls
            setupControlListeners();
        }

        function unlinkSpeakerPair(speaker) {
            if (!speaker.pairId) return;
            
            // Find the paired speaker
            const pairedSpeaker = currentStack.find(s => 
                s.pairId === speaker.pairId && s.id !== speaker.id
            );
            
            // Remove pair IDs from both speakers
            delete speaker.pairId;
            delete speaker.isLeftSpeaker;
            
            if (pairedSpeaker) {
                delete pairedSpeaker.pairId;
                delete pairedSpeaker.isLeftSpeaker;
                console.log('Unlinked speakers:', speaker.id, pairedSpeaker.id);
            }
            
            // Update UI
            renderControls();
            updateSpeakerList();
            updateExport();
        }

        function setupControlListeners() {
            const xInput = document.getElementById('xInput');
            const yInput = document.getElementById('yInput');
            const zInput = document.getElementById('zInput');
            const rotXInput = document.getElementById('rotXInput');
            const rotYInput = document.getElementById('rotYInput');
            const rotZInput = document.getElementById('rotZInput');
            const groundSelect = document.getElementById('groundSelect');
            const unlinkBtn = document.getElementById('unlinkBtn');

            if (xInput) {
                xInput.addEventListener('input', function() {
                    const newValue = parseInt(this.value) || 0;
                    console.log('X Input changed to:', newValue, 'for speaker:', selectedSpeaker.id, 'pairId:', selectedSpeaker.pairId);
                    selectedSpeaker.x = newValue;
                    selectedObject.position.x = newValue;
                    updatePairedSpeaker(selectedSpeaker, 'x', newValue);
                    updateSpeakerList();
                    updateExport();
                });
            }

            if (yInput) {
                yInput.addEventListener('input', function() {
                    const newValue = parseInt(this.value) || 0;
                    console.log('Y Input changed to:', newValue, 'for speaker:', selectedSpeaker.id, 'pairId:', selectedSpeaker.pairId);
                    console.log('Selected object position before:', selectedObject.position.y);
                    selectedSpeaker.y = newValue;
                    selectedObject.position.y = newValue;
                    console.log('Selected object position after:', selectedObject.position.y);
                    updatePairedSpeaker(selectedSpeaker, 'y', newValue);
                    updateSpeakerList();
                    updateExport();
                });
            }

            if (zInput) {
                zInput.addEventListener('input', function() {
                    const newValue = parseInt(this.value) || 0;
                    console.log('Z Input changed to:', newValue, 'for speaker:', selectedSpeaker.id, 'pairId:', selectedSpeaker.pairId);
                    selectedSpeaker.z = newValue;
                    selectedObject.position.z = newValue;
                    updatePairedSpeaker(selectedSpeaker, 'z', newValue);
                    updateSpeakerList();
                    updateExport();
                });
            }

            if (rotXInput) {
                rotXInput.addEventListener('input', function() {
                    const degrees = parseInt(this.value) || 0;
                    const radians = degrees * Math.PI / 180;
                    selectedSpeaker.rotationX = radians;
                    selectedObject.rotation.x = radians;
                    updatePairedSpeaker(selectedSpeaker, 'rotationX', radians);
                    updateSpeakerList();
                    updateExport();
                });
            }

            if (rotYInput) {
                rotYInput.addEventListener('input', function() {
                    const degrees = parseInt(this.value) || 0;
                    const radians = degrees * Math.PI / 180;
                    selectedSpeaker.rotationY = radians;
                    selectedObject.rotation.y = radians;
                    updatePairedSpeaker(selectedSpeaker, 'rotationY', radians);
                    updateSpeakerList();
                    updateExport();
                });
            }

            if (rotZInput) {
                rotZInput.addEventListener('input', function() {
                    const degrees = parseInt(this.value) || 0;
                    const radians = degrees * Math.PI / 180;
                    selectedSpeaker.rotationZ = radians;
                    selectedObject.rotation.z = radians;
                    updatePairedSpeaker(selectedSpeaker, 'rotationZ', radians);
                    updateSpeakerList();
                    updateExport();
                });
            }

            if (groundSelect) {
                groundSelect.addEventListener('change', function() {
                    const newValue = this.value === 'true';
                    selectedSpeaker.onGround = newValue;
                    updatePairedSpeaker(selectedSpeaker, 'onGround', newValue);
                    updateSpeakerList();
                    updateExport();
                });
            }

            if (unlinkBtn) {
                unlinkBtn.addEventListener('click', function() {
                    unlinkSpeakerPair(selectedSpeaker);
                });
            }
        }

        function deleteSpeaker(speakerId) {
            // Remove from stack
            currentStack = currentStack.filter(speaker => speaker.id !== speakerId);
            
            // Remove from scene
            for (let i = speakerObjects.length - 1; i >= 0; i--) {
                if (speakerObjects[i].userData.speakerId === speakerId) {
                    scene.remove(speakerObjects[i]);
                    speakerObjects.splice(i, 1);
                    break;
                }
            }
            
            // Clear selection
            selectedSpeaker = null;
            selectedObject = null;
            renderControls();
            updateExport();
        }

        function clearAll() {
            // Clear all speakers
            speakerObjects.forEach(obj => scene.remove(obj));
            speakerObjects = [];
            currentStack = [];
            selectedSpeaker = null;
            selectedObject = null;
            renderControls();
            updateExport();
        }

        function updateExport() {
            const stackNameEl = document.getElementById('stackName');
            const stackDescEl = document.getElementById('stackDescription');
            const stackSpacingEl = document.getElementById('stackSpacing');
            
            const stackName = stackNameEl ? stackNameEl.value : 'Custom Stack';
            const stackDescription = stackDescEl ? stackDescEl.value : 'Custom speaker configuration';
            const stackSpacing = stackSpacingEl ? parseInt(stackSpacingEl.value) || 3000 : 3000;

            if (currentStack.length === 0) {
                exportText.value = '';
                return;
            }

            const exportData = {
                id: stackName.toLowerCase().replace(/\s+/g, '-'),
                name: stackName,
                description: stackDescription,
                spacing: stackSpacing,
                speakers: currentStack.map(speaker => ({
                    model: speaker.model,
                    x: speaker.x,
                    y: speaker.y,
                    z: speaker.z,
                    rotationX: speaker.rotationX,
                    rotationY: speaker.rotationY,
                    rotationZ: speaker.rotationZ,
                    onGround: speaker.onGround
                }))
            };

            exportText.value = JSON.stringify(exportData, null, 2);
        }

        function onWindowResize() {
            const newWidth = canvas.clientWidth;
            const newHeight = canvas.clientHeight;
            
            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
        }
    </script>
</body>
</html>